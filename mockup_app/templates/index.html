<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GlareCheck.com</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/logos/favicon.ico">
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.2/font/bootstrap-icons.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <style>
        :root {
            --primary-blue: #4274a5;
            --accent-yellow: #ffc107;
            --text-primary: #333333;
            --text-secondary: #666666;
            --background-light: #f8fafc;
            --border-color: #e2e8f0;
            --header-height: 60px;
            --sidebar-width: 380px;
        }
        
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background-color: var(--background-light);
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        /* Header */
        .header {
            height: var(--header-height);
            background: white;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .header h1 {
            font-size: 1.5rem;
            margin: 0;
            color: var(--primary-blue);
            font-weight: 600;
        }
        
        /* Layout Container */
        .main-container {
            display: flex;
            height: calc(100vh - var(--header-height));
            margin-top: var(--header-height);
        }
        
        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            background: white;
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            flex-shrink: 0;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        /* Map Container */
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            height: 100%;
            width: 100%;
        }
        
        
        /* Menu Styles */
        .menu-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            color: var(--text-primary);
        }
        
        .menu-item:hover {
            background-color: var(--background-light);
        }
        
        .menu-item.active {
            background-color: #e3f2fd;
            color: var(--primary-blue);
            font-weight: 500;
        }
        
        .menu-item i {
            width: 20px;
            margin-right: 12px;
            font-size: 1.1rem;
        }
        
        .menu-section {
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .menu-section.collapsed .menu-item:not(.active) {
            display: none;
        }
        
        .back-button {
            display: none;
            padding: 8px 16px;
            margin: 10px 20px;
            background-color: #f8f9fa;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .back-button:hover {
            background-color: #e9ecef;
        }
        
        .menu-section.collapsed .back-button {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .current-function {
            display: none;
            padding: 12px 20px;
            background-color: var(--accent-yellow);
            color: var(--text-primary);
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
        }
        
        .menu-section.collapsed .current-function {
            display: block;
        }
        
        .menu-section h6 {
            padding: 0 20px;
            margin-bottom: 10px;
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Search Box */
        .search-box {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
        }
        
        .search-input:focus {
            outline: none;
            border-color: var(--primary-blue);
        }
        
        /* Content Panels */
        .content-panel {
            display: none;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }
        
        .content-panel.active {
            display: block;
            height: 100%;
        }
        
        /* Lists */
        .element-list {
            /* No height restriction - use full available space */
            overflow-y: auto;
        }
        
        /* Small form checks */
        .form-check-sm .form-check-input {
            width: 0.875rem;
            height: 0.875rem;
            margin-top: 0.125rem;
        }
        
        .form-check-sm .form-check-label {
            font-size: 0.75rem;
        }
        
        .element-item {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .element-item:hover {
            background-color: var(--background-light);
        }
        
        .pv-area-item .element-item {
            transition: background-color 0.2s;
        }
        
        .pv-area-item .element-item:hover {
            background-color: #f0f4f8;
        }
        
        /* Buttons */
        .btn-sm {
            padding: 4px 12px;
            font-size: 0.875rem;
        }
        
        .btn-delete {
            color: #dc3545;
            background: none;
            border: none;
            cursor: pointer;
        }
        
        .btn-delete:hover {
            color: #a02622;
        }
        
        /* Drag and Drop styles */
        .pv-area-item {
            transition: transform 0.2s;
        }
        
        .pv-area-item.dragging {
            opacity: 0.5;
        }
        
        .pv-area-item.drag-over-top {
            border-top: 3px solid #4274a5;
        }
        
        .pv-area-item.drag-over-bottom {
            border-bottom: 3px solid #4274a5;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header" style="display: flex; align-items: center; padding: 10px 20px;">
        <img src="/logos/GlearCheck_Logo_5.png" alt="GlareCheck Logo" style="height: 40px; margin-right: 15px;">
        <h1 style="margin: 0;">GlareCheck.com</h1>
    </header>
    
    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Current Function Display -->
            <div class="current-function" id="current-function">
                <i class="fas fa-tools"></i> <span id="current-function-text">Funktion</span>
            </div>
            
            <!-- Menu -->
            <div class="menu-section" id="menu-section">
                <div class="menu-header" id="menu-header">
                    <i class="fas fa-bars"></i>
                    <span>Hauptmenü</span>
                </div>
                
                <button class="back-button" onclick="backToMenu()">
                    <i class="fas fa-arrow-left"></i> Zurück zum Hauptmenü
                </button>
                
                <button class="menu-item" data-panel="search">
                    <i class="fas fa-search"></i>
                    Adresssuche
                </button>
                <button class="menu-item" data-panel="pv-areas">
                    <i class="fas fa-solar-panel"></i>
                    PV-Flächen
                </button>
                <button class="menu-item" data-panel="observation-points">
                    <i class="fas fa-eye"></i>
                    Betrachtungspunkte
                </button>
                <button class="menu-item" data-panel="excluded-areas">
                    <i class="fas fa-ban"></i>
                    Excluded Areas
                </button>
                <button class="menu-item" data-panel="obstacles">
                    <i class="fas fa-building"></i>
                    Hindernisse
                </button>
            </div>
            
            <!-- Content Panels -->
            
            <!-- Default Navigation Hint -->
            <div class="content-panel active" id="default-hint">
                <div class="text-center p-4">
                    <i class="fas fa-hand-pointer fa-3x text-muted mb-3"></i>
                    <h6 class="text-muted">Navigation</h6>
                    <p class="small text-muted">
                        Verwenden Sie die Maus, um die Karte zu bewegen und zu zoomen.
                    </p>
                    <hr class="my-3">
                    <p class="small text-muted">
                        Wählen Sie eine Funktion aus dem Menü, um zu beginnen.
                    </p>
                </div>
            </div>
            
            <!-- Search Panel -->
            <div class="content-panel" id="panel-search">
                <div class="submenu-header">
                    <span><i class="fas fa-search me-2"></i>Adresssuche</span>
                    <button class="btn btn-sm btn-outline-secondary" onclick="backToMenu()" style="padding: 0.25rem 0.5rem;">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                </div>
                
                <div class="p-3">
                    <div class="search-box p-0">
                        <input type="text" class="search-input" id="address-search" placeholder="Adresse eingeben...">
                        <button class="btn btn-primary btn-sm w-100 mt-2" onclick="searchAddress()">
                            <i class="fas fa-search"></i> Suchen
                        </button>
                    <div class="mt-3 small text-muted">
                        <p class="mb-1"><strong>Tipp:</strong> Auch Koordinaten möglich</p>
                        <p class="mb-0">Format: 48.1351, 11.5820</p>
                    </div>
                </div>
            </div>
            
            <!-- PV Areas Panel -->
            <div class="content-panel" id="panel-pv-areas">
                <div class="submenu-header">
                    <span><i class="fas fa-solar-panel me-2"></i>PV-Flächen Menü</span>
                    <button class="btn btn-sm btn-outline-secondary" onclick="backToMenu()" style="padding: 0.25rem 0.5rem;">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                </div>
                
                <div class="p-3">
                    <button class="btn btn-primary btn-sm w-100 mb-3" onclick="showPVTypeModal()">
                        <i class="fas fa-plus"></i> Neue PV-Fläche erstellen
                    </button>
                    
                    <h6>Vorhandene PV-Flächen:</h6>
                    <div class="element-list" id="pv-list">
                        <p class="text-muted small">Keine PV-Flächen vorhanden</p>
                    </div>
                </div>
            </div>
            
            <!-- PV Arrays Panel -->
            <!-- Observation Points Panel -->
            <div class="content-panel" id="panel-observation-points">
                <div class="submenu-header">
                    <span><i class="fas fa-eye me-2"></i>Betrachtungspunkte Menü</span>
                    <button class="btn btn-sm btn-outline-secondary" onclick="backToMenu()" style="padding: 0.25rem 0.5rem;">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                </div>
                
                <div class="p-3">
                    <button class="btn btn-warning btn-sm w-100 mb-3" onclick="startDrawingOP()">
                        <i class="fas fa-plus"></i> Neuen Betrachtungspunkt setzen
                    </button>
                
                <div class="mb-3">
                    <label class="form-label small">Beobachterhöhe (m):</label>
                    <input type="number" class="form-control form-control-sm" id="op-height-observer" value="1.5" step="0.1">
                </div>
                <div class="mb-3">
                    <label class="form-label small">Objekthöhe (m):</label>
                    <input type="number" class="form-control form-control-sm" id="op-height-object" value="10" step="0.1">
                </div>
                
                <h6>Vorhandene Betrachtungspunkte:</h6>
                <div class="element-list" id="op-list">
                    <p class="text-muted small">Keine Betrachtungspunkte vorhanden</p>
                </div>
            </div>
            
            <!-- Excluded Areas Panel -->
            <div class="content-panel" id="panel-excluded-areas">
                <div class="submenu-header">
                    <span><i class="fas fa-ban me-2"></i>Excluded Areas Menü</span>
                    <button class="btn btn-sm btn-outline-secondary" onclick="backToMenu()" style="padding: 0.25rem 0.5rem;">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                </div>
                
                <div class="p-3">
                    <button class="btn btn-danger btn-sm w-100 mb-3" onclick="startDrawingExcluded()">
                        <i class="fas fa-plus"></i> Neue Excluded Area zeichnen
                    </button>
                
                <h6>Vorhandene Excluded Areas:</h6>
                <div class="element-list" id="excluded-list">
                    <p class="text-muted small">Keine Excluded Areas vorhanden</p>
                </div>
            </div>
            
            <!-- Obstacles Panel -->
            <div class="content-panel" id="panel-obstacles">
                <div class="submenu-header">
                    <span><i class="fas fa-building me-2"></i>Hindernisse Menü</span>
                    <button class="btn btn-sm btn-outline-secondary" onclick="backToMenu()" style="padding: 0.25rem 0.5rem;">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                </div>
                
                <div class="p-3">
                    <button class="btn btn-secondary btn-sm w-100 mb-3" onclick="startDrawingObstacle()">
                        <i class="fas fa-plus"></i> Neues Hindernis zeichnen
                    </button>
                
                <div class="mb-3">
                    <label class="form-label small">Höhe (m):</label>
                    <input type="number" class="form-control form-control-sm" id="obstacle-height" value="10" step="0.5">
                </div>
                
                <h6>Vorhandene Hindernisse:</h6>
                <div class="element-list" id="obstacle-list">
                    <p class="text-muted small">Keine Hindernisse vorhanden</p>
                </div>
            </div>
        </aside>
        
        <!-- Map Container -->
        <div class="map-container">
            <div id="map"></div>
            
        </div>
    </div>
    
    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let map;
        let drawingManager;
        let currentMode = 'view';
        let pvAreas = [];
        let observationPoints = [];
        let tempPolyline = null;
        let tempPolygon = null;
        let rectanglePoints = [];
        let roofParallelEditor = null;
        
        // Module types with reflection profiles
        let moduleTypes = [
            {
                id: 1,
                name: 'Standardmodul',
                beamSpread: 0.5, // degrees
                reflectionProfile: {
                    0: 70000.00,    // cd/m²
                    10: 70000.00,
                    20: 71000.00,
                    30: 79000.00,
                    40: 120000.00,
                    50: 280000.00,
                    60: 930000.00,
                    70: 3900000.00,
                    80: 16134855.82,
                    90: 58377635.77
                }
            },
            {
                id: 2,
                name: 'Phytonics Anti Glare',
                beamSpread: 40, // degrees
                reflectionProfile: {
                    0: 2800.00,     // cd/m²
                    10: 2900.00,
                    20: 3200.00,
                    30: 3900.00,
                    40: 5400.00,
                    50: 9500.00,
                    60: 21000.00,
                    70: 65000.00,
                    80: 180000.00,
                    90: 510000.00
                }
            }
        ];
        
        // Helper function to show messages in modal instead of alert
        function showMessage(message, title = 'Hinweis') {
            const modal = document.getElementById('messageModal');
            const modalTitle = document.getElementById('messageModalLabel');
            const modalBody = document.getElementById('messageModalBody');
            
            modalTitle.textContent = title;
            modalBody.innerHTML = message;
            
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
        }
        
        // Make initMap globally accessible
        function initMap() {
            // Default center (Munich)
            let mapCenter = { lat: 48.1351, lng: 11.5820 };
            let mapZoom = 15;
            
            // Try to get location from IP
            fetch('https://ipapi.co/json/')
                .then(response => response.json())
                .then(data => {
                    if (data.latitude && data.longitude) {
                        mapCenter = { lat: data.latitude, lng: data.longitude };
                        map.setCenter(mapCenter);
                    }
                })
                .catch(error => {
                    console.log('IP-Geolocation failed, using default location');
                });
            
            // Initialize map
            map = new google.maps.Map(document.getElementById('map'), {
                center: mapCenter,
                zoom: mapZoom,
                mapTypeId: 'hybrid', // Satellite with labels
                mapTypeControl: false, // No map type switching
                streetViewControl: false,
                fullscreenControl: false, // No fullscreen button
                // Disable 3D buildings and tilt
                tilt: 0,
                rotateControl: false,
                // Custom styles to remove POIs and improve label visibility
                styles: [
                    // Hide all points of interest
                    {
                        featureType: "poi",
                        elementType: "all",
                        stylers: [{ visibility: "off" }]
                    },
                    // Hide transit stations
                    {
                        featureType: "transit",
                        elementType: "all",
                        stylers: [{ visibility: "off" }]
                    },
                    // Make road labels more visible with white color and black outline
                    {
                        featureType: "road",
                        elementType: "labels.text.fill",
                        stylers: [
                            { color: "#ffffff" },
                            { weight: 2 }
                        ]
                    },
                    {
                        featureType: "road",
                        elementType: "labels.text.stroke",
                        stylers: [
                            { color: "#000000" },
                            { weight: 3 }
                        ]
                    },
                    // Make other labels more visible
                    {
                        featureType: "administrative",
                        elementType: "labels.text.fill",
                        stylers: [{ color: "#ffffff" }]
                    },
                    {
                        featureType: "administrative",
                        elementType: "labels.text.stroke",
                        stylers: [
                            { color: "#000000" },
                            { weight: 2 }
                        ]
                    },
                    // Hide business icons
                    {
                        featureType: "poi.business",
                        stylers: [{ visibility: "off" }]
                    },
                    // Hide parks
                    {
                        featureType: "poi.park",
                        elementType: "labels",
                        stylers: [{ visibility: "off" }]
                    }
                ]
            });
            
            // Initialize drawing manager
            drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: false,
                polygonOptions: {
                    fillColor: '#4274a5',
                    fillOpacity: 0.4,
                    strokeWeight: 2,
                    strokeColor: '#4274a5',
                    editable: true,
                    draggable: true
                },
                rectangleOptions: {
                    fillColor: '#4274a5',
                    fillOpacity: 0.3,
                    strokeWeight: 2,
                    strokeColor: '#4274a5',
                    strokeOpacity: 1,
                    editable: false,
                    draggable: false
                },
                markerOptions: {
                    draggable: true
                }
            });
            
            drawingManager.setMap(map);
            
            // No zoom capping - let Google Maps handle it naturally
            
            // Drawing complete listeners
            google.maps.event.addListener(drawingManager, 'polygoncomplete', function(polygon) {
                // Check the PV type
                const pvType = window.selectedPVType;
                
                // First handle PV area completion to set up pvAreaData
                handlePVAreaComplete(polygon);
                
                // For roof-parallel, use special editing
                if (pvType === 'roof-parallel') {
                    enhancePolygonEditing(polygon, true, 'roof-parallel');
                }
                // For all other types, just use standard Google Maps editing
                // The corner numbers are already added by updateCornerMarkers in handlePVAreaComplete
                
                drawingManager.setDrawingMode(null);
                setMode('view');
            });
            
            google.maps.event.addListener(drawingManager, 'polylinecomplete', function(polyline) {
                // Handle facade completion
                handleFacadeComplete(polyline);
                drawingManager.setDrawingMode(null);
                setMode('view');
            });
            
            google.maps.event.addListener(drawingManager, 'markercomplete', function(marker) {
                handleObservationPointComplete(marker);
                drawingManager.setDrawingMode(null);
                setMode('view');
            });
            
            // ESC key handler to cancel drawing
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && drawingManager.getDrawingMode() !== null) {
                    drawingManager.setDrawingMode(null);
                }
            });
            
            // Initialize autocomplete for address search
            const searchInput = document.getElementById('address-search');
            const autocomplete = new google.maps.places.Autocomplete(searchInput, {
                // Restrict to Germany and nearby countries
                componentRestrictions: { country: ['de', 'at', 'ch'] },
                fields: ['address_components', 'geometry', 'name'],
                types: ['address']
            });
            
            // When user selects an address from dropdown
            autocomplete.addListener('place_changed', function() {
                const place = autocomplete.getPlace();
                if (!place.geometry || !place.geometry.location) {
                    alert("Keine Details für diese Adresse verfügbar");
                    return;
                }
                
                // Center map on selected location
                map.setCenter(place.geometry.location);
                map.setZoom(18);
            });
        }
        
        function setMode(mode) {
            currentMode = mode;
            
            // Simply reset drawing mode to view mode
            if (mode === 'view') {
                drawingManager.setDrawingMode(null);
            }
        }
        
        function handlePVAreaComplete(polygon) {
            const corners = [];
            const bounds = {
                north: -90,
                south: 90,
                east: -180,
                west: 180
            };
            
            // Extract corners and calculate bounds
            polygon.getPath().forEach(function(latLng) {
                const lat = latLng.lat();
                const lng = latLng.lng();
                
                corners.push({
                    latitude: lat,
                    longitude: lng,
                    ground_elevation: 0
                });
                
                // Update bounds
                bounds.north = Math.max(bounds.north, lat);
                bounds.south = Math.min(bounds.south, lat);
                bounds.east = Math.max(bounds.east, lng);
                bounds.west = Math.min(bounds.west, lng);
            });
            
            // Calculate center point
            const center = {
                latitude: (bounds.north + bounds.south) / 2,
                longitude: (bounds.east + bounds.west) / 2
            };
            
            // Calculate area (approximate)
            const latDistance = (bounds.north - bounds.south) * 111320; // meters per degree latitude
            const lngDistance = (bounds.east - bounds.west) * 111320 * Math.cos(center.latitude * Math.PI / 180);
            const approximateArea = Math.abs(latDistance * lngDistance);
            
            // Map the selected type to display names and default parameters
            const typeMapping = {
                'roof-parallel': {
                    displayName: 'Dachparallel',
                    defaultAzimuth: 180,
                    defaultTilt: 30,
                    moduleType: 0
                },
                'roof-mounted': {
                    displayName: 'Dachanlage (aufgeständert)',
                    defaultAzimuth: 180,
                    defaultTilt: 15,
                    moduleType: 0
                },
                'facade': {
                    displayName: 'Fassade',
                    defaultAzimuth: 180,
                    defaultTilt: 90,
                    moduleType: 1
                },
                'ground': {
                    displayName: 'Freifläche',
                    defaultAzimuth: 180,
                    defaultTilt: 25,
                    moduleType: 0
                }
            };
            
            const selectedType = window.selectedPVType || 'ground';
            const typeInfo = typeMapping[selectedType];
            
            // Create comprehensive PV area object
            const pvArea = {
                // Identification
                id: `pv_area_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                name: '',
                
                // Type information
                type: selectedType,
                displayType: typeInfo.displayName,
                moduleType: typeInfo.moduleType,
                
                // Geometry
                corners: corners,
                bounds: bounds,
                center: center,
                approximateArea: approximateArea,
                
                // PV parameters
                azimuth: typeInfo.defaultAzimuth,
                tilt: typeInfo.defaultTilt,
                moduleTypeId: 1, // Default to Standardmodul
                
                // Metadata
                createdAt: new Date().toISOString(),
                modifiedAt: new Date().toISOString(),
                
                // Map reference (not serializable, will be excluded from saves)
                polygon: polygon,
                
                // Drawing metadata (for reconstruction)
                isParallelogram: selectedType === 'roof-parallel',
                parallelogramPoints: selectedType === 'roof-parallel' ? {
                    p1: { lat: corners[0].latitude, lng: corners[0].longitude },
                    p2: { lat: corners[1].latitude, lng: corners[1].longitude },
                    p3: { lat: corners[2].latitude, lng: corners[2].longitude },
                    p4: { lat: corners[3].latitude, lng: corners[3].longitude }
                } : null,
                
                // UI state
                isNew: true,  // Flag to auto-expand in UI
                autoCalculateAzimuth: true  // Default to auto-calculate
            };
            
            // Auto-calculate azimuth for roof-parallel areas
            if (pvArea.type === 'roof-parallel' && pvArea.autoCalculateAzimuth) {
                pvArea.azimuth = calculatePVAreaAzimuth(polygon);
            }
            
            // Calculate perpendicular distance for roof-parallel areas
            if (pvArea.type === 'roof-parallel') {
                pvArea.perpendicularDistance = calculatePerpendicularDistance(polygon);
                
                // Initialize height calculation fields
                pvArea.autoCalculateField = 'tilt'; // Default: auto-calculate tilt
                pvArea.heightTop = null; // No default value
                pvArea.heightBottom = null; // No default value
                pvArea.autoCalculateReferenceHeight = true; // Default: auto-calculate reference height
                
                // Calculate reference height from Google Elevation API
                calculateReferenceHeight(pvArea);
            }
            
            // Initialize corner markers array
            pvArea.cornerMarkers = [];
            
            // Store reference to polygon in pvArea
            pvArea.polygon = polygon;
            
            // Store reference to pvArea on the polygon for easy access
            polygon.pvAreaData = pvArea;
            
            // Mark all existing PV areas as not new
            pvAreas.forEach(pv => pv.isNew = false);
            
            // Mark this one as new to expand it in UI
            pvArea.isNew = true;
            
            pvAreas.push(pvArea);
            
            // Add corner markers immediately after creating the PV area
            console.log('Creating corner markers for type:', pvArea.type);
            updateCornerMarkers(pvArea);
            
            // Create PV label - TEMPORARILY DISABLED
            // createPVLabel(pvArea);
            
            console.log('PV Area created:', {
                type: pvArea.type,
                displayType: pvArea.displayType,
                name: pvArea.name,
                isNew: pvArea.isNew,
                totalAreas: pvAreas.length
            });
            
            // Mark polygon as roof area only if it's roof-parallel type
            if (pvArea.type === 'roof-parallel') {
                polygon.isRoofArea = true;
            }
            
            // Add path change listener to update corner count
            google.maps.event.addListener(polygon.getPath(), 'set_at', function() {
                // Path was modified, update corner markers if visible
                if (pvArea.cornerMarkers && pvArea.cornerMarkers.length > 0) {
                    updateCornerMarkers(pvArea);
                }
                // Update label position
                if (pvArea.labelMarker) {
                    const path = pvArea.polygon.getPath();
                    if (path.getLength() > 0) {
                        pvArea.labelMarker.setPosition(path.getAt(0));
                    }
                }
                // Update dimension labels if shown
                if (pvArea.showDimensions) {
                    updatePVDimensions(pvArea);
                }
            });
            
            google.maps.event.addListener(polygon.getPath(), 'insert_at', function() {
                // New point was added, update corner markers if visible
                if (pvArea.cornerMarkers && pvArea.cornerMarkers.length > 0) {
                    updateCornerMarkers(pvArea);
                }
                // Update corner heights dialog if it's open for this PV area
                updateCornerHeightsDialogIfOpen(pvArea.id);
                // Update dimension labels to include new edge
                if (pvArea.showDimensions) {
                    updatePVDimensions(pvArea);
                }
            });
            
            google.maps.event.addListener(polygon.getPath(), 'remove_at', function() {
                // Point was removed, update corner markers if visible
                if (pvArea.cornerMarkers && pvArea.cornerMarkers.length > 0) {
                    updateCornerMarkers(pvArea);
                }
                // Update corner heights dialog if it's open for this PV area
                updateCornerHeightsDialogIfOpen(pvArea.id);
                // Update dimension labels to remove edge
                if (pvArea.showDimensions) {
                    updatePVDimensions(pvArea);
                }
            });
            
            // Add dragstart listener to hide dimensions while dragging
            google.maps.event.addListener(polygon, 'dragstart', function() {
                // Hide dimension labels while dragging
                if (pvArea.showDimensions && pvArea.dimensionOverlays) {
                    pvArea.dimensionOverlays.forEach(overlay => {
                        overlay.setMap(null);
                    });
                }
            });
            
            // Add dragend listener to update dimensions
            google.maps.event.addListener(polygon, 'dragend', function() {
                // Update dimension labels if shown (this will recreate them)
                if (pvArea.showDimensions) {
                    updatePVDimensions(pvArea);
                }
                
                // Update corner markers if visible
                if (pvArea.cornerMarkers && pvArea.cornerMarkers.length > 0) {
                    updateCornerMarkers(pvArea);
                }
            });
            
            // Add click listener to highlight/select polygon
            google.maps.event.addListener(polygon, 'click', function() {
                // Highlight the polygon
                polygon.setOptions({
                    fillOpacity: 0.6,
                    strokeWeight: 3
                });
                
                // Reset opacity after a moment
                setTimeout(() => {
                    polygon.setOptions({
                        fillOpacity: 0.4,
                        strokeWeight: 2
                    });
                }, 300);
                
                // Optionally scroll to the PV area in the list
                const pvElement = document.querySelector(`[data-pv-id="${pvArea.id}"]`);
                if (pvElement) {
                    pvElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    pvElement.classList.add('bg-light');
                    setTimeout(() => {
                        pvElement.classList.remove('bg-light');
                    }, 1000);
                }
            });
            
            // Send to backend (exclude non-serializable polygon reference)
            const serializableData = { ...pvArea };
            delete serializableData.polygon;
            delete serializableData.labelOverlay;
            delete serializableData.labelLine;
            delete serializableData.cornerMarkers;
            
            fetch('/api/pv_area', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(serializableData)
            });
            
            // Hide drawing instructions modal if it's open
            const instructionsModalElement = document.getElementById('drawingInstructionsModal');
            const instructionsModal = bootstrap.Modal.getInstance(instructionsModalElement);
            if (instructionsModal) {
                instructionsModal.hide();
            }
            // Force hide the modal backdrop if it exists
            const backdrop = document.querySelector('.modal-backdrop');
            if (backdrop) {
                backdrop.remove();
            }
            // Remove modal-open class from body
            document.body.classList.remove('modal-open');
            // Reset body padding
            document.body.style.paddingRight = '';
            
            // Update UI after modal is closed
            setTimeout(() => {
                updateUI();
                
                // Ensure PV panel is visible
                const pvPanel = document.getElementById('panel-pv-areas');
                if (pvPanel && !pvPanel.classList.contains('active')) {
                    console.log('PV panel not active, activating it');
                    // Switch to PV panel
                    document.querySelectorAll('.content-panel').forEach(p => p.classList.remove('active'));
                    pvPanel.classList.add('active');
                    
                    // Update menu
                    document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('active'));
                    const pvMenuItem = document.querySelector('[data-panel="pv-areas"]');
                    if (pvMenuItem) {
                        pvMenuItem.classList.add('active');
                    }
                }
            }, 150);
        }
        
        function handleFacadeComplete(polyline) {
            // Remove the polyline immediately - we'll create a visual representation
            const path = polyline.getPath();
            const points = [];
            
            // Extract points from polyline
            for (let i = 0; i < path.getLength(); i++) {
                points.push(path.getAt(i));
            }
            
            // Remove original polyline
            polyline.setMap(null);
            
            // Calculate azimuth from line direction
            if (points.length >= 2) {
                const startPoint = points[0];
                const endPoint = points[points.length - 1];
                
                // Calculate azimuth: direction perpendicular to the line, pointing right
                const lineHeading = google.maps.geometry.spherical.computeHeading(startPoint, endPoint);
                const facadeAzimuth = (lineHeading + 90 + 360) % 360;
                
                // Create visual representation with orange highlight on reflective side
                const facadeId = createFacadeVisualization(points, facadeAzimuth);
                
                // Create PV area data for facade
                const bounds = new google.maps.LatLngBounds();
                points.forEach(p => bounds.extend(p));
                
                const corners = points.map(p => ({
                    latitude: p.lat(),
                    longitude: p.lng(),
                    ground_elevation: 0
                }));
                
                // Create PV area object
                const pvArea = {
                    id: `pv_area_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    name: '',
                    type: 'facade',
                    displayType: 'Fassade',
                    moduleType: 1,
                    corners: corners,
                    bounds: {
                        north: bounds.getNorthEast().lat(),
                        south: bounds.getSouthWest().lat(),
                        east: bounds.getNorthEast().lng(),
                        west: bounds.getSouthWest().lng()
                    },
                    center: {
                        latitude: bounds.getCenter().lat(),
                        longitude: bounds.getCenter().lng()
                    },
                    azimuth: Math.round(facadeAzimuth),
                    tilt: 90, // Vertical
                    moduleTypeId: 1,
                    createdAt: new Date().toISOString(),
                    modifiedAt: new Date().toISOString(),
                    isNew: true,
                    autoCalculateAzimuth: false, // Fixed based on line direction
                    facadeLine: points, // Store line points for visualization
                    facadeVisualizationId: facadeId // Store visualization ID for cleanup
                };
                
                // Add to pvAreas
                pvAreas.push(pvArea);
                
                // Create PV label
                createPVLabel(pvArea);
                
                // Update UI
                updateUI();
                
                // Send to backend
                const serializableData = { ...pvArea };
                delete serializableData.facadeLine;
                
                fetch('/api/pv_area', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(serializableData)
                });
            }
        }
        
        function createFacadeVisualization(points, azimuth) {
            // Create the main line (facade line)
            const facadeLine = new google.maps.Polyline({
                path: points,
                strokeColor: '#4274a5',
                strokeWeight: 4,
                strokeOpacity: 1.0,
                map: map,
                zIndex: 500
            });
            
            // Create orange highlight on the reflective side
            const highlightPoints = [];
            
            // Calculate offset for highlight (to the right of the line)
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                let bearing;
                
                if (i < points.length - 1) {
                    // Calculate perpendicular bearing
                    const nextPoint = points[i + 1];
                    const lineHeading = google.maps.geometry.spherical.computeHeading(point, nextPoint);
                    bearing = lineHeading + 90; // Right side
                } else if (i > 0) {
                    // For last point, use bearing from previous segment
                    const prevPoint = points[i - 1];
                    const lineHeading = google.maps.geometry.spherical.computeHeading(prevPoint, point);
                    bearing = lineHeading + 90;
                } else {
                    bearing = azimuth;
                }
                
                // Create offset point (about 3 meters to show the highlight)
                const offsetPoint = google.maps.geometry.spherical.computeOffset(point, 3, bearing);
                highlightPoints.push(offsetPoint);
            }
            
            // Create filled polygon to show reflective side
            const reflectiveArea = new google.maps.Polygon({
                paths: [points, highlightPoints.reverse()],
                strokeColor: '#FFA500',
                strokeWeight: 2,
                strokeOpacity: 0.8,
                fillColor: '#FFA500',
                fillOpacity: 0.3,
                map: map,
                zIndex: 450
            });
            
            // Store references for later manipulation
            const facadeId = `facade_${Date.now()}`;
            window.facadeVisualizations = window.facadeVisualizations || {};
            window.facadeVisualizations[facadeId] = {
                line: facadeLine,
                reflectiveArea: reflectiveArea,
                azimuth: azimuth
            };
            
            return facadeId;
        }
        
        function handleObservationPointComplete(marker) {
            const op = {
                marker: marker,
                name: `OP ${observationPoints.length + 1}`,
                latitude: marker.getPosition().lat(),
                longitude: marker.getPosition().lng(),
                height_observer: parseFloat(document.getElementById('op-height-observer').value),
                height_object: parseFloat(document.getElementById('op-height-object').value)
            };
            
            observationPoints.push(op);
            
            // Add custom icon
            marker.setIcon({
                url: 'https://maps.google.com/mapfiles/ms/icons/yellow-dot.png'
            });
            
            // Add click listener for deletion
            google.maps.event.addListener(marker, 'click', function() {
                if (currentMode === 'view' && confirm('Diesen Beobachtungspunkt löschen?')) {
                    marker.setMap(null);
                    observationPoints = observationPoints.filter(o => o.marker !== marker);
                    updateUI();
                }
            });
            
            // Send to backend
            fetch('/api/observation_point', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(op)
            });
            
            updateUI();
        }
        
        
        function updateUI() {
            console.log('updateUI called, total PV areas:', pvAreas.length);
            
            // Save current expanded states before updating
            const expandedStates = {};
            document.querySelectorAll('.pv-area-item').forEach(item => {
                const pvId = item.getAttribute('data-pv-id');
                const details = item.querySelector('.pv-details');
                if (details && !details.classList.contains('d-none')) {
                    expandedStates[pvId] = true;
                }
            });
            
            // Update PV Areas list
            const pvList = document.getElementById('pv-list');
            if (!pvList) {
                console.error('PV list element not found!');
                return;
            }
            
            pvList.innerHTML = pvAreas.length > 0 ? '' : '<p class="text-muted small">Keine PV-Flächen vorhanden</p>';
            pvAreas.forEach((pv, i) => {
                console.log(`Processing PV area ${i}:`, pv.type, pv.displayType);
                // Expand only new PV areas, others should be collapsed
                const isExpanded = pv.isNew === true;
                pvList.innerHTML += `
                    <div class="pv-area-item mb-2" data-pv-id="${pv.id}" 
                         ondragover="handleDragOver(event)" 
                         ondrop="handleDrop(event, '${pv.id}')"
                         ondragenter="handleDragEnter(event)"
                         ondragleave="handleDragLeave(event)">
                        <div class="element-item d-flex align-items-center" style="cursor: pointer;" onclick="togglePVDetails('${pv.id}')">
                            <i class="fas fa-grip-vertical text-muted me-2" style="cursor: grab;" 
                               draggable="true" 
                               ondragstart="handleDragStart(event, '${pv.id}')" 
                               ondragend="handleDragEnd(event)"
                               onclick="event.stopPropagation()"></i>
                            <i class="fas fa-chevron-${isExpanded ? 'down' : 'right'}" id="chevron-${pv.id}" class="me-2" style="width: 20px;"></i>
                            <span class="flex-grow-1">PV${i + 1}${pv.name ? `: ${pv.name}` : ''}</span>
                            <button class="btn btn-link btn-sm p-0 text-danger" onclick="event.stopPropagation(); deletePVArea('${pv.id}')" title="Löschen">
                                <i class="fas fa-trash-alt"></i>
                            </button>
                        </div>
                        <div class="pv-details ps-2 mt-2 ${isExpanded ? '' : 'd-none'}" id="details-${pv.id}">
                            <div class="small border-start border-2 ps-2 pe-1">
                                <div class="d-flex gap-1 mb-2 pb-2 border-bottom">
                                    <button class="btn btn-sm btn-outline-secondary flex-fill" style="padding: 0.2rem;"
                                            onclick="focusPVArea('${pv.id}')" title="Auf Karte zeigen">
                                        <i class="fas fa-crosshairs"></i>
                                    </button>
                                    <button class="btn btn-sm ${pv.locked ? 'btn-warning' : 'btn-outline-secondary'} flex-fill" style="padding: 0.2rem;"
                                            onclick="togglePVLock('${pv.id}')" title="${pv.locked ? 'Entsperren' : 'Sperren'}">
                                        <i class="fas fa-${pv.locked ? 'lock' : 'unlock'}"></i>
                                    </button>
                                    <button class="btn btn-sm ${pv.showDimensions ? 'btn-primary' : 'btn-outline-secondary'} flex-fill" style="padding: 0.2rem;"
                                            onclick="togglePVDimensions('${pv.id}')" title="Bemaßen">
                                        <i class="fas fa-ruler-combined"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline-secondary flex-fill" style="padding: 0.2rem;"
                                            onclick="exportPVArea('${pv.id}')" title="Exportieren">
                                        <i class="fas fa-download"></i>
                                    </button>
                                </div>
                                <div class="mb-2">
                                    <label class="form-label mb-1" style="font-size: 0.75rem;">Typ</label>
                                    <input type="text" class="form-control form-control-sm" value="${pv.displayType || pv.type}" 
                                           style="background-color: #f8f9fa;"
                                           disabled>
                                </div>
                                <div class="mb-2">
                                    <label class="form-label mb-1" style="font-size: 0.75rem;">
                                        Bezeichnung
                                        <i class="bi bi-info-circle text-muted ms-1" 
                                           style="cursor: pointer; font-size: 0.75rem;" 
                                           data-bs-toggle="tooltip" 
                                           data-bs-placement="top"
                                           data-bs-html="true"
                                           title="Optionale Bezeichnung für diese PV-Fläche.<br><br>Beispiele:<br>• Hauptdach Süd<br>• Garage<br>• Carport<br><br>Die Bezeichnung hilft bei der Identifikation mehrerer PV-Flächen.">
                                        </i>
                                    </label>
                                    <input type="text" class="form-control form-control-sm" value="${pv.name}" 
                                           placeholder="(optional)"
                                           onchange="updatePVParameter('${pv.id}', 'name', this.value)">
                                </div>
                                ${pv.type !== 'roof-mounted' ? `
                                <div class="mb-2">
                                    <div class="mb-2">
                                        <label class="form-label mb-1" style="font-size: 0.75rem;">
                                            Azimut (°)
                                            <i class="bi bi-info-circle text-muted ms-1" 
                                               style="cursor: pointer; font-size: 0.75rem;" 
                                               data-bs-toggle="tooltip" 
                                               data-bs-placement="top"
                                               data-bs-html="true"
                                               title="Der Azimut definiert die Ausrichtung der PV-Fläche.<br><br>360° Referenzsystem:<br>0° = Norden<br>90° = Osten<br>180° = Süden<br>270° = Westen">
                                            </i>
                                        </label>
                                        <div class="d-flex align-items-center gap-2">
                                            <input type="number" class="form-control form-control-sm" value="${pv.azimuth}" 
                                                   min="0" max="360" step="1" id="azimuth-${pv.id}"
                                                   style="max-width: 80px;"
                                                   ${pv.autoCalculateAzimuth !== false ? 'disabled' : ''}
                                                   onchange="updatePVParameter('${pv.id}', 'azimuth', this.value)">
                                            <div class="form-check">
                                                <input class="form-check-input" type="checkbox" id="auto-calc-${pv.id}" 
                                                       ${pv.autoCalculateAzimuth !== false ? 'checked' : ''}
                                                       onchange="toggleAutoCalculate('${pv.id}', this.checked)">
                                                <label class="form-check-label small" for="auto-calc-${pv.id}" style="white-space: nowrap;">
                                                    Auto-calculate
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                </div>` : ''}
                                    ${pv.type === 'roof-parallel' ? `
                                    <div class="border rounded p-2 mb-2 position-relative" style="background-color: #f8f9fa;">
                                        <i class="bi bi-info-circle text-muted position-absolute" 
                                           style="cursor: pointer; font-size: 0.875rem; top: 8px; right: 8px;" 
                                           data-bs-toggle="tooltip" 
                                           data-bs-placement="left"
                                           data-bs-html="true"
                                           title="Die drei Werte Neigung, Höhe Oberkante und Höhe Unterkante sind mathematisch verknüpft.<br><br>Mit der bekannten Distanz zwischen Ober- und Unterkante können Sie einen Wert automatisch berechnen lassen, wenn die anderen beiden bekannt sind.<br><br>Formel: tan(Neigung) = (Höhe Oberkante - Höhe Unterkante) / Distanz"></i>
                                        <div class="mb-2">
                                            <label class="form-label mb-1" style="font-size: 0.75rem;">
                                                Neigung (°)
                                                <i class="bi bi-info-circle text-muted ms-1" 
                                                   style="cursor: pointer; font-size: 0.75rem;" 
                                                   data-bs-toggle="tooltip" 
                                                   data-bs-placement="top"
                                                   data-bs-html="true"
                                                   title="Die Neigung beschreibt den Winkel der PV-Fläche gegenüber der Horizontalen.<br><br>0° = horizontal (flach)<br>90° = vertikal (senkrecht)">
                                                </i>
                                            </label>
                                            <div class="d-flex align-items-center gap-2">
                                                <input type="number" class="form-control form-control-sm" value="${pv.tilt}"
                                                       min="0" max="89" step="0.1" id="tilt-${pv.id}"
                                                       style="max-width: 80px;"
                                                       ${pv.autoCalculateField === 'tilt' ? 'disabled' : ''}
                                                       onchange="updatePVParameter('${pv.id}', 'tilt', this.value)">
                                                <div class="form-check form-check-sm mb-0">
                                                    <input class="form-check-input" type="checkbox" 
                                                           id="auto-calc-tilt-${pv.id}"
                                                           ${pv.autoCalculateField === 'tilt' ? 'checked' : ''}
                                                           onchange="setAutoCalculateField('${pv.id}', 'tilt', this.checked)">
                                                    <label class="form-check-label small" for="auto-calc-tilt-${pv.id}" style="white-space: nowrap;">
                                                        Auto-calculate
                                                    </label>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="mb-2">
                                            <label class="form-label mb-1" style="font-size: 0.75rem;">
                                                Höhe Oberkante (m) <span style="color: #00CED1; font-weight: bold; font-size: 1.2em;">━━</span>
                                                <i class="bi bi-info-circle text-muted ms-1" 
                                                   style="cursor: pointer; font-size: 0.75rem;" 
                                                   data-bs-toggle="tooltip" 
                                                   data-bs-placement="top"
                                                   data-bs-html="true"
                                                   title="Absolute Höhe der oberen Kante (türkis) der PV-Fläche.<br><br>Diese Höhe bezieht sich auf die Geländeoberkante bzw. Referenzhöhe.">
                                                </i>
                                            </label>
                                            <div class="d-flex align-items-center gap-2">
                                                <input type="number" class="form-control form-control-sm" 
                                                       value="${pv.heightTop || ''}"
                                                       min="0" max="1000" step="0.1" id="height-top-${pv.id}"
                                                       style="max-width: 80px;"
                                                       ${pv.autoCalculateField === 'heightTop' ? 'disabled' : ''}
                                                       onchange="updatePVParameter('${pv.id}', 'heightTop', this.value)">
                                                <div class="form-check form-check-sm mb-0">
                                                    <input class="form-check-input" type="checkbox" 
                                                           id="auto-calc-height-top-${pv.id}"
                                                           ${pv.autoCalculateField === 'heightTop' ? 'checked' : ''}
                                                           onchange="setAutoCalculateField('${pv.id}', 'heightTop', this.checked)">
                                                    <label class="form-check-label small" for="auto-calc-height-top-${pv.id}" style="white-space: nowrap;">
                                                        Auto-calculate
                                                    </label>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="mb-2">
                                            <label class="form-label mb-1" style="font-size: 0.75rem;">
                                                Höhe Unterkante (m) <span style="color: #FF8C00; font-weight: bold; font-size: 1.2em;">━━</span>
                                                <i class="bi bi-info-circle text-muted ms-1" 
                                                   style="cursor: pointer; font-size: 0.75rem;" 
                                                   data-bs-toggle="tooltip" 
                                                   data-bs-placement="top"
                                                   data-bs-html="true"
                                                   title="Absolute Höhe der unteren Kante (orange) der PV-Fläche.<br><br>Diese Höhe bezieht sich auf die Geländeoberkante bzw. Referenzhöhe.">
                                                </i>
                                            </label>
                                            <div class="d-flex align-items-center gap-2">
                                                <input type="number" class="form-control form-control-sm" 
                                                       value="${pv.heightBottom || ''}"
                                                       min="0" max="1000" step="0.1" id="height-bottom-${pv.id}"
                                                       style="max-width: 80px;"
                                                       ${pv.autoCalculateField === 'heightBottom' ? 'disabled' : ''}
                                                       onchange="updatePVParameter('${pv.id}', 'heightBottom', this.value)">
                                                <div class="form-check form-check-sm mb-0">
                                                    <input class="form-check-input" type="checkbox" 
                                                           id="auto-calc-height-bottom-${pv.id}"
                                                           ${pv.autoCalculateField === 'heightBottom' ? 'checked' : ''}
                                                           onchange="setAutoCalculateField('${pv.id}', 'heightBottom', this.checked)">
                                                    <label class="form-check-label small" for="auto-calc-height-bottom-${pv.id}" style="white-space: nowrap;">
                                                        Auto-calculate
                                                    </label>
                                                </div>
                                            </div>
                                        </div>
                                        <div>
                                            <label class="form-label mb-1" style="font-size: 0.75rem;">Distanz Ober- zur Unterkante (m)</label>
                                            <input type="text" class="form-control form-control-sm" 
                                                   value="${pv.perpendicularDistance ? pv.perpendicularDistance.toFixed(1) : '—'}"
                                                   style="max-width: 80px;"
                                                   disabled>
                                        </div>
                                        <div class="mt-2">
                                            <button class="btn btn-sm btn-outline-secondary w-100" 
                                                    onclick="swapTopBottom('${pv.id}')"
                                                    title="Vertauscht Ober- und Unterkante der PV-Fläche">
                                                <i class="fas fa-exchange-alt fa-rotate-90"></i> Ober-/Unterkante tauschen
                                            </button>
                                        </div>
                                    </div>
                                    <div>
                                        <label class="form-label mb-1" style="font-size: 0.75rem;">
                                            Referenzhöhe / Geländeoberkante (m)
                                            <i class="bi bi-info-circle text-muted ms-1" 
                                               style="cursor: pointer; font-size: 0.75rem;" 
                                               data-bs-toggle="tooltip" 
                                               data-bs-placement="top"
                                               data-bs-html="true"
                                               title="Die Referenzhöhe ist die Basis für alle Höhenangaben.<br><br>Sie entspricht der Geländeoberkante an der Position der PV-Fläche.<br><br>Alle Höhen (Oberkante, Unterkante) beziehen sich auf diese Referenz.">
                                            </i>
                                        </label>
                                        <div class="d-flex align-items-center gap-2">
                                            <input type="number" class="form-control form-control-sm" 
                                                   value="${pv.referenceHeight || 0}"
                                                   min="-100" max="5000" step="0.1" id="reference-height-${pv.id}"
                                                   style="max-width: 80px;"
                                                   ${pv.autoCalculateReferenceHeight !== false ? 'disabled' : ''}
                                                   onchange="updatePVParameter('${pv.id}', 'referenceHeight', this.value)">
                                            <div class="form-check">
                                                <input class="form-check-input" type="checkbox" id="auto-calc-ref-${pv.id}" 
                                                       ${pv.autoCalculateReferenceHeight !== false ? 'checked' : ''}
                                                       onchange="toggleAutoCalculateReference('${pv.id}', this.checked)">
                                                <label class="form-check-label small" for="auto-calc-ref-${pv.id}" style="white-space: nowrap;">
                                                    Auto-calculate
                                                    <i class="bi bi-info-circle text-muted ms-1" 
                                                       style="cursor: pointer; font-size: 0.75rem;" 
                                                       data-bs-toggle="tooltip" 
                                                       data-bs-placement="top"
                                                       data-bs-html="true"
                                                       title="Bei aktiviertem Auto-calculate wird die Höhe über Google Elevation API ermittelt.<br><br>Es wird der Mittelwert der Geländehöhen aller Eckpunkte berechnet.">
                                                    </i>
                                                </label>
                                            </div>
                                        </div>
                                    </div>` : pv.type === 'roof-mounted' ? `
                                    <div class="mb-2">
                                        <label class="form-label mb-1" style="font-size: 0.75rem;">
                                            Azimut (°)
                                            <i class="bi bi-info-circle text-muted ms-1" 
                                               style="cursor: pointer; font-size: 0.75rem;" 
                                               data-bs-toggle="tooltip" 
                                               data-bs-placement="top"
                                               data-bs-html="true"
                                               title="Der Azimut definiert die Ausrichtung der PV-Fläche.<br><br>360° Referenzsystem:<br>0° = Norden<br>90° = Osten<br>180° = Süden<br>270° = Westen">
                                            </i>
                                        </label>
                                        <input type="number" class="form-control form-control-sm" value="${pv.azimuth}" 
                                               min="0" max="360" step="1"
                                               style="max-width: 80px;"
                                               onchange="updatePVParameter('${pv.id}', 'azimuth', this.value)">
                                    </div>
                                    <div class="mb-2">
                                        <label class="form-label mb-1" style="font-size: 0.75rem;">
                                            Neigung (°)
                                            <i class="bi bi-info-circle text-muted ms-1" 
                                               style="cursor: pointer; font-size: 0.75rem;" 
                                               data-bs-toggle="tooltip" 
                                               data-bs-placement="top"
                                               data-bs-html="true"
                                               title="Die Neigung beschreibt den Winkel der PV-Fläche gegenüber der Horizontalen.<br><br>0° = horizontal (flach)<br>90° = vertikal (senkrecht)">
                                            </i>
                                        </label>
                                        <input type="number" class="form-control form-control-sm" value="${pv.tilt}"
                                               min="0" max="90" step="1"
                                               style="max-width: 80px;"
                                               onchange="updatePVParameter('${pv.id}', 'tilt', this.value)">
                                    </div>
                                    <div class="mb-2">
                                        <label class="form-label mb-1" style="font-size: 0.75rem;">
                                            Querneigung (°) <span id="cross-tilt-direction-${pv.id}" class="text-muted small"></span>
                                            <i class="bi bi-info-circle text-muted ms-1" 
                                               style="cursor: pointer; font-size: 0.75rem;" 
                                               data-bs-toggle="tooltip" 
                                               data-bs-placement="top"
                                               data-bs-html="true"
                                               title="Die Querneigung beschreibt die Neigung entlang der Tischachse (orthogonal zum Azimut).<br><br>Dies beeinflusst die effektive Ausrichtung der PV-Module.<br><br><strong>Hinweis:</strong> Wenn eine Fläche unterschiedliche Querneigungen aufweist, sollte diese durch entsprechende Einzelflächen dargestellt werden.">
                                            </i>
                                        </label>
                                        <input type="number" class="form-control form-control-sm" value="${pv.crossTilt || 0}"
                                               min="-45" max="45" step="0.1"
                                               style="max-width: 80px;"
                                               onchange="updatePVParameter('${pv.id}', 'crossTilt', this.value)">
                                    </div>
                                    <div class="mb-3">
                                        <button class="btn btn-outline-primary btn-sm w-100" 
                                                onclick="console.log('Button clicked for:', '${pv.id}'); console.log('Panel exists:', !!document.getElementById('cornerHeightsPanel')); console.log('All IDs:', Array.from(document.querySelectorAll('[id]')).map(el => el.id).filter(id => id.includes('corner'))); openCornerHeightsDialog('${pv.id}')"
                                                style="font-size: 0.875rem;">
                                            <i class="fas fa-ruler-vertical me-2"></i>
                                            Eckpunkt-Höhen verwalten
                                        </button>
                                    </div>` : `
                                    <div>
                                        <label class="form-label mb-1" style="font-size: 0.75rem;">
                                            Neigung (°)
                                            <i class="bi bi-info-circle text-muted ms-1" 
                                               style="cursor: pointer; font-size: 0.75rem;" 
                                               data-bs-toggle="tooltip" 
                                               data-bs-placement="top"
                                               data-bs-html="true"
                                               title="Die Neigung beschreibt den Winkel der PV-Fläche gegenüber der Horizontalen.<br><br>0° = horizontal (flach)<br>90° = vertikal (senkrecht)">
                                            </i>
                                        </label>
                                        <input type="number" class="form-control form-control-sm" value="${pv.tilt}"
                                               min="0" max="90" step="1"
                                               style="max-width: 80px;"
                                               onchange="updatePVParameter('${pv.id}', 'tilt', this.value)">
                                    </div>
                                    <div class="mb-2">
                                        <label class="form-label mb-1" style="font-size: 0.75rem;">
                                            Querneigung (°) <span id="cross-tilt-direction-${pv.id}" class="text-muted small"></span>
                                            <i class="bi bi-info-circle text-muted ms-1" 
                                               style="cursor: pointer; font-size: 0.75rem;" 
                                               data-bs-toggle="tooltip" 
                                               data-bs-placement="top"
                                               data-bs-html="true"
                                               title="Die Querneigung beschreibt die Neigung entlang der Tischachse (orthogonal zum Azimut).<br><br>Dies beeinflusst die effektive Ausrichtung der PV-Module.<br><br><strong>Hinweis:</strong> Wenn eine Fläche unterschiedliche Querneigungen aufweist, sollte diese durch entsprechende Einzelflächen dargestellt werden.">
                                            </i>
                                        </label>
                                        <input type="number" class="form-control form-control-sm" value="${pv.crossTilt || 0}"
                                               min="-45" max="45" step="0.1"
                                               style="max-width: 80px;"
                                               onchange="updatePVParameter('${pv.id}', 'crossTilt', this.value)">
                                    </div>
                                    <div class="mb-3">
                                        <button class="btn btn-outline-primary btn-sm w-100" 
                                                onclick="console.log('Button clicked for:', '${pv.id}'); console.log('Panel exists:', !!document.getElementById('cornerHeightsPanel')); console.log('All IDs:', Array.from(document.querySelectorAll('[id]')).map(el => el.id).filter(id => id.includes('corner'))); openCornerHeightsDialog('${pv.id}')"
                                                style="font-size: 0.875rem;">
                                            <i class="fas fa-ruler-vertical me-2"></i>
                                            Eckpunkt-Höhen verwalten
                                        </button>
                                    </div>`}
                                    <div id="effective-values-${pv.id}" class="alert alert-info p-2 mb-2" style="display: none; font-size: 0.875rem;">
                                        <div class="row">
                                            <div class="col-6">
                                                <strong>Effektiver Azimut:</strong> <span id="effective-azimuth-${pv.id}"></span>
                                                <i class="bi bi-info-circle text-muted ms-1" 
                                                   style="cursor: pointer; font-size: 0.75rem;" 
                                                   data-bs-toggle="tooltip" 
                                                   data-bs-placement="top"
                                                   data-bs-html="true"
                                                   title="Der effektive Azimut ist die durch die Querneigung korrigierte Ausrichtung.<br><br>Dieser Wert wird in der Simulation berücksichtigt.">
                                                </i>
                                            </div>
                                            <div class="col-6">
                                                <strong>Effektive Neigung:</strong> <span id="effective-tilt-${pv.id}"></span>
                                                <i class="bi bi-info-circle text-muted ms-1" 
                                                   style="cursor: pointer; font-size: 0.75rem;" 
                                                   data-bs-toggle="tooltip" 
                                                   data-bs-placement="top"
                                                   data-bs-html="true"
                                                   title="Die effektive Neigung ist der durch die Querneigung korrigierte Neigungswinkel.<br><br>Dieser Wert wird in der Simulation berücksichtigt.">
                                                </i>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="mb-2 mt-3">
                                        <label class="form-label mb-1" style="font-size: 0.75rem;">
                                            Modultyp
                                            <i class="bi bi-info-circle text-muted ms-1" 
                                               style="cursor: pointer; font-size: 0.75rem;" 
                                               data-bs-toggle="tooltip" 
                                               data-bs-placement="top"
                                               data-bs-html="true"
                                               title="Der Modultyp bestimmt das Reflexionsverhalten der PV-Module.<br><br>Verschiedene Module haben unterschiedliche Reflexionsprofile.">
                                            </i>
                                        </label>
                                        <div class="input-group input-group-sm">
                                            <select class="form-select form-select-sm" 
                                                    id="module-type-${pv.id}"
                                                    onchange="updatePVParameter('${pv.id}', 'moduleTypeId', this.value)">
                                                ${moduleTypes.map(m => `
                                                    <option value="${m.id}" ${pv.moduleTypeId === m.id ? 'selected' : ''}>
                                                        ${m.name}
                                                    </option>
                                                `).join('')}
                                            </select>
                                            <button class="btn btn-sm btn-outline-secondary" type="button" 
                                                    onclick="openModuleTypeManager()"
                                                    title="Modultypen verwalten">
                                                <i class="bi bi-gear"></i>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
            });
            
            // Update Observation Points list
            const opList = document.getElementById('op-list');
            opList.innerHTML = observationPoints.length > 0 ? '' : '<p class="text-muted small">Keine Betrachtungspunkte vorhanden</p>';
            observationPoints.forEach((op, i) => {
                opList.innerHTML += `
                    <div class="element-item">
                        <span>${op.name}</span>
                        <small class="text-muted">H: ${op.height_observer}m / ${op.height_object}m</small>
                    </div>
                `;
            });
            
            // Initialize tooltips for newly added elements
            const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
            const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
            
            // Update cross tilt directions
            pvAreas.forEach(pv => {
                updateCrossTiltDirection(pv.id);
            });
        }
        
        // Menu navigation with animations
        document.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', function() {
                const menuSection = document.getElementById('menu-section');
                const menuHeader = document.getElementById('menu-header');
                
                // Add slide out animation
                menuSection.classList.add('sliding-out');
                
                setTimeout(() => {
                    // Update active menu
                    document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update menu header for submenu
                    const icon = this.querySelector('i').className;
                    const text = this.textContent.trim();
                    menuHeader.innerHTML = `<i class="${icon}"></i><span>${text} Menü</span>`;
                    
                    // Show corresponding panel with animation
                    const panelId = 'panel-' + this.dataset.panel;
                    document.querySelectorAll('.content-panel').forEach(p => {
                        p.classList.remove('active');
                        p.style.animation = 'none';
                    });
                    const targetPanel = document.getElementById(panelId);
                    targetPanel.classList.add('active');
                    targetPanel.style.animation = 'slideInPanel 0.3s ease-out forwards';
                    
                    // Collapse menu and show current function
                    menuSection.classList.add('collapsed');
                    menuSection.classList.remove('sliding-out');
                    menuSection.classList.add('sliding-in');
                    
                    // Update current function display
                    const functionText = document.getElementById('current-function-text');
                    document.getElementById('current-function').querySelector('i').className = icon;
                    functionText.textContent = text;
                    
                    // Remove sliding-in class after animation
                    setTimeout(() => {
                        menuSection.classList.remove('sliding-in');
                    }, 300);
                }, 150);
                
                // Always reset drawing mode when switching functions
                drawingManager.setDrawingMode(null);
            });
        });
        
        // Back to menu function with animation
        function backToMenu() {
            const menuSection = document.getElementById('menu-section');
            const menuHeader = document.getElementById('menu-header');
            
            // Add slide out animation for content
            const activePanel = document.querySelector('.content-panel.active');
            if (activePanel) {
                activePanel.style.animation = 'slideOutPanel 0.3s ease-out forwards';
            }
            
            setTimeout(() => {
                // Reset menu header to main menu
                menuHeader.innerHTML = '<i class="fas fa-bars"></i><span>Hauptmenü</span>';
                
                // Expand menu with animation
                menuSection.classList.remove('collapsed');
                menuSection.classList.add('sliding-in');
                
                // Reset all active states
                document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('active'));
                document.querySelectorAll('.content-panel').forEach(p => {
                    p.classList.remove('active');
                    p.style.animation = 'none';
                });
                
                // Show default hint with animation
                const defaultHint = document.getElementById('default-hint');
                defaultHint.classList.add('active');
                defaultHint.style.animation = 'slideInPanel 0.3s ease-out forwards';
                
                // Remove animation class after completion
                setTimeout(() => {
                    menuSection.classList.remove('sliding-in');
                }, 300);
            }, 150);
            
            // Navigation is now the default mode
            drawingManager.setDrawingMode(null);
        }
        
        // Show PV type selection modal
        function showPVTypeModal() {
            const modal = new bootstrap.Modal(document.getElementById('pvTypeModal'));
            modal.show();
        }
        
        // Select PV type and show instructions
        function selectPVType(type) {
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('pvTypeModal'));
            modal.hide();
            
            // Store selected type
            window.selectedPVType = type;
            
            // Show appropriate instructions
            const instructionsContent = document.getElementById('drawingInstructionsContent');
            
            switch(type) {
                case 'roof-parallel':
                    instructionsContent.innerHTML = `
                        <div class="mb-3">
                            <h6 class="text-primary"><i class="fas fa-info-circle"></i> Dachparallele PV-Fläche</h6>
                        </div>
                        <div class="alert alert-info">
                            <p class="mb-2"><strong>So zeichnen Sie die Fläche:</strong></p>
                            <ol class="mb-0">
                                <li>Zeichnen Sie die erste Linie entlang der oberen oder unteren Kante der PV-Fläche</li>
                                <li>Versuchen Sie die PV-Fläche so gut es geht mit einem Viereck zu erfassen</li>
                                <li>Das Viereck kann nach Vollendung noch frei angepasst werden</li>
                            </ol>
                        </div>
                        <p class="small text-muted mb-0">
                            <i class="fas fa-keyboard"></i> Mit <kbd>ESC</kbd> können Sie jederzeit abbrechen<br>
                            <i class="fas fa-edit"></i> Im Nachgang können Eckpunkte, Kantenpositionen und Kantenlängen angepasst werden<br>
                            <i class="fas fa-ban"></i> Mit der Funktion "PV-Fläche ausschließen" können Sie noch Bereiche ausschließen (z.B. Dachfenster, Schornsteine etc.), die Sie ggf. überzeichnen
                        </p>
                    `;
                    break;
                case 'roof-mounted':
                    instructionsContent.innerHTML = `
                        <div class="mb-3">
                            <h6 class="text-primary"><i class="fas fa-solar-panel"></i> Aufgeständerte Dachanlage</h6>
                        </div>
                        <div class="alert alert-info">
                            <p class="mb-2"><strong>So zeichnen Sie die Fläche:</strong></p>
                            <ul class="mb-0">
                                <li>Klicken Sie nacheinander die Eckpunkte der Aufstellfläche</li>
                                <li>Schließen Sie das Polygon mit Doppelklick</li>
                            </ul>
                        </div>
                        <p class="small text-muted mb-0">
                            <i class="fas fa-keyboard"></i> Mit <kbd>ESC</kbd> können Sie jederzeit abbrechen
                        </p>
                    `;
                    break;
                case 'facade':
                    instructionsContent.innerHTML = `
                        <div class="mb-3">
                            <h6 class="text-primary"><i class="fas fa-building"></i> Fassadenanlage</h6>
                        </div>
                        <div class="alert alert-info">
                            <p class="mb-2"><strong>So zeichnen Sie die Fassade:</strong></p>
                            <ul class="mb-0">
                                <li>Zeichnen Sie eine Linie entlang der Fassade</li>
                                <li>Die <span style="color: #FFA500; font-weight: bold;">orange Seite</span> zeigt die reflektierende Seite (PV-Module)</li>
                                <li>Die Ausrichtung ergibt sich aus der Zeichenrichtung</li>
                                <li>Beenden Sie mit Doppelklick oder Enter</li>
                            </ul>
                        </div>
                        <div class="alert alert-warning">
                            <small><i class="fas fa-info-circle"></i> <strong>Tipp:</strong> Zeichnen Sie von links nach rechts, um die PV-Module nach Süden auszurichten</small>
                        </div>
                        <p class="small text-muted mb-0">
                            <i class="fas fa-keyboard"></i> Mit <kbd>ESC</kbd> können Sie jederzeit abbrechen
                        </p>
                    `;
                    break;
                case 'ground':
                    instructionsContent.innerHTML = `
                        <div class="mb-3">
                            <h6 class="text-primary"><i class="fas fa-seedling"></i> Freiflächenanlage</h6>
                        </div>
                        <div class="alert alert-info">
                            <p class="mb-2"><strong>So zeichnen Sie die Fläche:</strong></p>
                            <ul class="mb-0">
                                <li>Umfahren Sie die gewünschte Fläche mit Klicks</li>
                                <li>Schließen Sie das Polygon mit Doppelklick</li>
                            </ul>
                        </div>
                        <p class="small text-muted mb-0">
                            <i class="fas fa-keyboard"></i> Mit <kbd>ESC</kbd> können Sie jederzeit abbrechen
                        </p>
                    `;
                    break;
            }
            
            // Show instructions modal
            const instructionsModal = new bootstrap.Modal(document.getElementById('drawingInstructionsModal'));
            instructionsModal.show();
        }
        
        // Start drawing after instructions
        function startDrawingAfterInstructions() {
            const type = window.selectedPVType;
            
            switch(type) {
                case 'roof-parallel':
                    // 3-click parallelogram for roof-parallel
                    startDrawingParallelogram();
                    break;
                case 'facade':
                    // Polyline drawing for facades
                    drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYLINE);
                    drawingManager.setOptions({
                        polylineOptions: {
                            strokeWeight: 4,
                            strokeColor: '#4274a5',
                            strokeOpacity: 1.0,
                            editable: true,
                            draggable: true
                        }
                    });
                    break;
                case 'roof-mounted':
                case 'ground':
                    // Polygon drawing for other types
                    drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
                    drawingManager.setOptions({
                        polygonOptions: {
                            fillColor: '#4274a5',
                            fillOpacity: 0.4,
                            strokeWeight: 2,
                            strokeColor: '#4274a5',
                            editable: true,
                            draggable: true
                        }
                    });
                    break;
            }
        }
        
        // Rectangle drawing for roof areas
        function startDrawingRectangle() {
            // Clear any existing drawing mode
            drawingManager.setDrawingMode(null);
            rectanglePoints = [];
            
            // Clean up any existing temp elements
            if (tempPolyline) {
                tempPolyline.setMap(null);
                tempPolyline = null;
            }
            if (tempPolygon) {
                tempPolygon.setMap(null);
                tempPolygon = null;
            }
            
            // Set map cursor and disable map dragging during drawing
            map.setOptions({ 
                draggableCursor: 'crosshair',
                draggingCursor: 'crosshair'
            });
            
            // Add click listener for rectangle drawing
            const clickListener = google.maps.event.addListener(map, 'click', function(e) {
                e.stop();  // Prevent event propagation
                rectanglePoints.push(e.latLng);
                
                if (rectanglePoints.length === 1) {
                    // First point - start showing line preview
                } else if (rectanglePoints.length === 2) {
                    // Second point - fix the line
                    if (tempPolyline) tempPolyline.setMap(null);
                    tempPolyline = new google.maps.Polyline({
                        path: rectanglePoints,
                        strokeColor: '#4274a5',
                        strokeWeight: 2,
                        map: map,
                        clickable: false
                    });
                } else if (rectanglePoints.length === 3) {
                    // Third point - complete rectangle
                    google.maps.event.removeListener(clickListener);
                    google.maps.event.removeListener(moveListener);
                    map.setOptions({ 
                        draggableCursor: null,
                        draggingCursor: null
                    });
                    
                    if (tempPolyline) {
                        tempPolyline.setMap(null);
                        tempPolyline = null;
                    }
                    if (tempPolygon) {
                        tempPolygon.setMap(null);
                        tempPolygon = null;
                    }
                    
                    // Calculate fourth point to make rectangle
                    const rect = calculateRectangle(rectanglePoints[0], rectanglePoints[1], rectanglePoints[2]);
                    
                    // Create final polygon
                    const polygon = new google.maps.Polygon({
                        paths: rect,
                        fillColor: '#4274a5',
                        fillOpacity: 0.4,
                        strokeWeight: 2,
                        strokeColor: '#4274a5',
                        editable: true,
                        draggable: true,
                        map: map
                    });
                    
                    // Prevent any automatic view adjustments
                    e.stop();
                    
                    handlePVAreaComplete(polygon);
                }
            });
            
            // Add mouse move listener for preview
            const moveListener = google.maps.event.addListener(map, 'mousemove', function(e) {
                if (rectanglePoints.length === 1) {
                    // Show line from first point to mouse
                    if (tempPolyline) tempPolyline.setMap(null);
                    tempPolyline = new google.maps.Polyline({
                        path: [rectanglePoints[0], e.latLng],
                        strokeColor: '#4274a5',
                        strokeWeight: 2,
                        strokeOpacity: 0.6,
                        map: map,
                        clickable: false
                    });
                } else if (rectanglePoints.length === 2) {
                    // Just show line from point 2 to mouse
                    if (tempPolygon) tempPolygon.setMap(null);
                    if (tempPolyline) tempPolyline.setMap(null);
                    
                    // Show line from point 2 to current mouse position
                    tempPolyline = new google.maps.Polyline({
                        path: [rectanglePoints[1], e.latLng],
                        strokeColor: '#4274a5',
                        strokeWeight: 2,
                        strokeOpacity: 0.6,
                        map: map,
                        clickable: false
                    });
                }
            });
            
            // ESC key handler for rectangle mode
            const escHandler = function(e) {
                if (e.key === 'Escape') {
                    google.maps.event.removeListener(clickListener);
                    google.maps.event.removeListener(moveListener);
                    document.removeEventListener('keydown', escHandler);
                    map.setOptions({ 
                        draggableCursor: null,
                        draggingCursor: null
                    });
                    if (tempPolyline) {
                        tempPolyline.setMap(null);
                        tempPolyline = null;
                    }
                    if (tempPolygon) {
                        tempPolygon.setMap(null);
                        tempPolygon = null;
                    }
                    rectanglePoints = [];
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        // Constrain a point to move along a line defined by two points
        function constrainToLine(point, lineStart, lineEnd) {
            // Convert to vectors
            const p = { lat: point.lat(), lng: point.lng() };
            const a = { lat: lineStart.lat(), lng: lineStart.lng() };
            const b = { lat: lineEnd.lat(), lng: lineEnd.lng() };
            
            // Vector from A to B
            const ab = {
                lat: b.lat - a.lat,
                lng: b.lng - a.lng
            };
            
            // Vector from A to P
            const ap = {
                lat: p.lat - a.lat,
                lng: p.lng - a.lng
            };
            
            // Project AP onto AB
            const abSquared = ab.lat * ab.lat + ab.lng * ab.lng;
            const apDotAb = ap.lat * ab.lat + ap.lng * ab.lng;
            const t = apDotAb / abSquared;
            
            // Constrained point
            const constrained = {
                lat: a.lat + t * ab.lat,
                lng: a.lng + t * ab.lng
            };
            
            return new google.maps.LatLng(constrained.lat, constrained.lng);
        }
        
        // Calculate parallelogram from 3 points
        // p1-p2 is the first edge, p3 is the opposite corner from p2
        function calculateRectangle(p1, p2, p3) {
            // Vector from p2 to p3 (diagonal)
            const v23 = {
                lat: p3.lat() - p2.lat(),
                lng: p3.lng() - p2.lng()
            };
            
            // Fourth point: p1 + vector(p2 to p3)
            // This creates point 4 by adding the diagonal vector to p1
            const p4 = new google.maps.LatLng(
                p1.lat() + v23.lat,
                p1.lng() + v23.lng
            );
            
            // Return points in correct order: 1, 2, 3, 4
            // This creates a proper parallelogram
            return [p1, p2, p3, p4];
        }
        
        // Simple 3-click parallelogram drawing
        function startDrawingParallelogram() {
            drawingManager.setDrawingMode(null);
            const points = [];
            let tempMarkers = [];
            let tempPolyline = null;
            let tempPolygon = null;
            let cornerOverlays = [];
            
            // Helper function to create corner number overlay
            function createCornerOverlay(position, number) {
                const overlay = new google.maps.OverlayView();
                
                overlay.onAdd = function() {
                    const div = document.createElement('div');
                    div.style.position = 'absolute';
                    div.style.backgroundColor = '#4274a5';
                    div.style.color = 'white';
                    div.style.padding = '2px 6px';
                    div.style.borderRadius = '12px';
                    div.style.fontSize = '12px';
                    div.style.fontWeight = 'bold';
                    div.style.border = '2px solid white';
                    div.style.cursor = 'default';
                    div.style.userSelect = 'none';
                    div.style.zIndex = '1000';
                    div.textContent = number.toString();
                    
                    const panes = this.getPanes();
                    panes.floatPane.appendChild(div);
                    this.div = div;
                };
                
                overlay.draw = function() {
                    const projection = this.getProjection();
                    const pos = projection.fromLatLngToDivPixel(position);
                    if (this.div) {
                        this.div.style.left = (pos.x - 12) + 'px';
                        this.div.style.top = (pos.y - 12) + 'px';
                    }
                };
                
                overlay.onRemove = function() {
                    if (this.div) {
                        this.div.parentNode.removeChild(this.div);
                        this.div = null;
                    }
                };
                
                overlay.setMap(map);
                return overlay;
            }
            
            // Clean up function
            function cleanup() {
                tempMarkers.forEach(m => m.setMap(null));
                cornerOverlays.forEach(o => o.setMap(null));
                if (tempPolyline) tempPolyline.setMap(null);
                if (tempPolygon) tempPolygon.setMap(null);
                document.removeEventListener('keydown', escHandler);
            }
            
            // ESC handler
            const escHandler = function(e) {
                if (e.key === 'Escape') {
                    cleanup();
                    document.getElementById('default-hint').classList.add('active');
                    document.getElementById('pv-drawing-hint').classList.remove('active');
                }
            };
            document.addEventListener('keydown', escHandler);
            
            // Click handler
            const clickListener = google.maps.event.addListener(map, 'click', function(e) {
                const point = e.latLng;
                points.push(point);
                
                // Create marker for this point
                const marker = new google.maps.Marker({
                    position: point,
                    map: map,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 8,
                        fillColor: '#4274a5',
                        fillOpacity: 0.8,
                        strokeColor: 'white',
                        strokeWeight: 2
                    },
                    draggable: false
                });
                tempMarkers.push(marker);
                
                // Create corner number overlay
                const cornerOverlay = createCornerOverlay(point, points.length);
                cornerOverlays.push(cornerOverlay);
                
                // Update preview polyline/polygon
                if (points.length > 1) {
                    if (tempPolyline) tempPolyline.setMap(null);
                    tempPolyline = new google.maps.Polyline({
                        path: points,
                        strokeColor: '#4274a5',
                        strokeWeight: 2,
                        strokeOpacity: 0.8,
                        map: map
                    });
                }
                
                if (points.length > 2) {
                    if (tempPolygon) tempPolygon.setMap(null);
                    tempPolygon = new google.maps.Polygon({
                        paths: points,
                        fillColor: '#4274a5',
                        fillOpacity: 0.3,
                        strokeColor: '#4274a5',
                        strokeWeight: 2,
                        strokeOpacity: 0.8,
                        map: map
                    });
                }
            });
            
            // Double-click to finish
            const dblClickListener = google.maps.event.addListener(map, 'dblclick', function(e) {
                if (points.length >= 3) {
                    // Remove listeners
                    google.maps.event.removeListener(clickListener);
                    google.maps.event.removeListener(dblClickListener);
                    google.maps.event.removeListener(moveListener);
                    
                    // Clean up temp elements
                    cleanup();
                    
                    // Create final polygon
                    const polygon = new google.maps.Polygon({
                        paths: points,
                        fillColor: '#4274a5',
                        fillOpacity: 0.4,
                        strokeWeight: 2,
                        strokeColor: '#4274a5',
                        editable: false,
                        draggable: true,
                        map: map
                    });
                    
                    // Handle completion
                    handlePVAreaComplete(polygon);
                    enhancePolygonEditing(polygon, true);
                    
                    // Reset hints
                    document.getElementById('default-hint').classList.add('active');
                    document.getElementById('pv-drawing-hint').classList.remove('active');
                }
            });
            
            // Mouse move for preview
            const moveListener = google.maps.event.addListener(map, 'mousemove', function(e) {
                if (points.length > 0) {
                    const previewPoints = [...points, e.latLng];
                    
                    if (points.length === 1) {
                        if (tempPolyline) tempPolyline.setMap(null);
                        tempPolyline = new google.maps.Polyline({
                            path: previewPoints,
                            strokeColor: '#4274a5',
                            strokeWeight: 2,
                            strokeOpacity: 0.5,
                            strokeDasharray: [5, 5],
                            map: map
                        });
                    } else if (points.length >= 2) {
                        if (tempPolygon) tempPolygon.setMap(null);
                        tempPolygon = new google.maps.Polygon({
                            paths: previewPoints,
                            fillColor: '#4274a5',
                            fillOpacity: 0.2,
                            strokeColor: '#4274a5',
                            strokeWeight: 2,
                            strokeOpacity: 0.5,
                            strokeDasharray: [5, 5],
                            map: map
                        });
                    }
                }
            });
        }
        
        // Simple 3-click parallelogram drawing
        function startDrawingParallelogram() {
            drawingManager.setDrawingMode(null);
            const points = [];
            let tempMarkers = [];
            let tempPolyline = null;
            let tempPolygon = null;
            
            // Set cursor and disable other interactions
            map.setOptions({ 
                draggableCursor: 'crosshair',
                draggingCursor: 'crosshair',
                disableDoubleClickZoom: true
            });
            
            // Click listener with high priority
            const clickListener = google.maps.event.addListenerOnce(map, 'click', function handler(e) {
                // Prevent any conflicts
                if (e.stop) e.stop();
                
                points.push(e.latLng);
                
                // Add numbered marker at click point
                const marker = new google.maps.Marker({
                    position: e.latLng,
                    map: map,
                    label: {
                        text: points.length.toString(),
                        color: '#FFFFFF',
                        fontSize: '14px',
                        fontWeight: 'bold'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 4,
                        fillColor: '#FFFFFF',
                        fillOpacity: 1,
                        strokeColor: '#000000',
                        strokeWeight: 2,
                        labelOrigin: new google.maps.Point(0, -4)
                    },
                    clickable: false,
                    zIndex: 1000
                });
                tempMarkers.push(marker);
                
                if (points.length === 1) {
                    // Re-register for next click
                    google.maps.event.addListenerOnce(map, 'click', handler);
                } else if (points.length === 2) {
                    // Draw line between first two points in turquoise
                    if (tempPolyline) tempPolyline.setMap(null);
                    tempPolyline = new google.maps.Polyline({
                        path: points,
                        strokeColor: '#00CED1',  // Turquoise
                        strokeWeight: 4,  // Thicker line
                        map: map,
                        clickable: false,
                        zIndex: 999
                    });
                    // Re-register for final click
                    google.maps.event.addListenerOnce(map, 'click', handler);
                } else if (points.length === 3) {
                    // Complete parallelogram immediately
                    google.maps.event.removeListener(moveListener);
                    map.setOptions({ 
                        draggableCursor: null,
                        draggingCursor: null,
                        disableDoubleClickZoom: false
                    });
                    
                    // Clean up temporary elements (but keep markers for a moment)
                    if (tempPolyline) tempPolyline.setMap(null);
                    if (tempPolygon) tempPolygon.setMap(null);
                    if (window.tempPolyline2) {
                        window.tempPolyline2.setMap(null);
                        window.tempPolyline2 = null;
                    }
                    
                    // Create final parallelogram
                    const parallelogramPoints = calculateRectangle(points[0], points[1], points[2]);
                    
                    // Add marker for 4th point
                    const p4 = parallelogramPoints[2]; // 4th point in the array
                    const marker4 = new google.maps.Marker({
                        position: p4,
                        map: map,
                        label: {
                            text: '4',
                            color: '#FFFFFF',
                            fontSize: '14px',
                            fontWeight: 'bold'
                        },
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 4,
                            fillColor: '#FFFFFF',
                            fillOpacity: 1,
                            strokeColor: '#000000',
                            strokeWeight: 2,
                            labelOrigin: new google.maps.Point(0, -4)
                        },
                        clickable: false,
                        zIndex: 1000
                    });
                    tempMarkers.push(marker4);
                    
                    // Remove temporary markers after a short delay
                    setTimeout(() => {
                        tempMarkers.forEach(m => m.setMap(null));
                    }, 500);
                    
                    const polygon = new google.maps.Polygon({
                        paths: parallelogramPoints,
                        fillColor: '#4274a5',
                        fillOpacity: 0.4,
                        strokeWeight: 2,
                        strokeColor: '#4274a5',
                        editable: false,  // Disable Google's built-in editing for roof areas
                        draggable: true,
                        map: map
                    });
                    
                    // First handle PV area completion to set up pvAreaData
                    handlePVAreaComplete(polygon);
                    // Then add enhanced editing with roof-parallel mode
                    enhancePolygonEditing(polygon, true, 'roof-parallel');
                    
                    // Clean up ESC handler
                    document.removeEventListener('keydown', escHandler);
                }
            });
            
            // Mouse move listener for preview
            const moveListener = google.maps.event.addListener(map, 'mousemove', function(e) {
                if (points.length === 1) {
                    // Preview line in turquoise
                    if (tempPolyline) tempPolyline.setMap(null);
                    tempPolyline = new google.maps.Polyline({
                        path: [points[0], e.latLng],
                        strokeColor: '#00CED1',  // Turquoise
                        strokeWeight: 4,  // Thicker line
                        strokeOpacity: 0.6,
                        map: map,
                        clickable: false,
                        zIndex: 998
                    });
                } else if (points.length === 2) {
                    // Preview parallelogram with mouse at point 3 (opposite corner from p2)
                    if (tempPolygon) tempPolygon.setMap(null);
                    // Don't remove tempPolyline here - we want to keep the turquoise line visible!
                    
                    // Calculate the preview parallelogram
                    const previewPoints = calculateRectangle(points[0], points[1], e.latLng);
                    
                    // Create parallelogram preview without stroke
                    tempPolygon = new google.maps.Polygon({
                        paths: previewPoints,
                        fillColor: '#4274a5',
                        fillOpacity: 0.2,
                        strokeWeight: 0,  // No stroke to not interfere with colored lines
                        map: map,
                        clickable: false,
                        zIndex: 996
                    });
                    
                    // Add preview of the orange line P3-P4
                    if (window.tempPolyline2) window.tempPolyline2.setMap(null);
                    window.tempPolyline2 = new google.maps.Polyline({
                        path: [previewPoints[2], previewPoints[3]],  // P3-P4
                        strokeColor: '#FF8C00',  // Orange
                        strokeWeight: 4,
                        strokeOpacity: 0.6,
                        map: map,
                        clickable: false,
                        zIndex: 998
                    });
                }
            });
            
            // ESC to cancel
            const escHandler = function(e) {
                if (e.key === 'Escape') {
                    google.maps.event.removeListener(clickListener);
                    google.maps.event.removeListener(moveListener);
                    document.removeEventListener('keydown', escHandler);
                    map.setOptions({ 
                        draggableCursor: null,
                        draggingCursor: null,
                        disableDoubleClickZoom: false
                    });
                    
                    // Clean up
                    tempMarkers.forEach(m => m.setMap(null));
                    if (tempPolyline) tempPolyline.setMap(null);
                    if (tempPolygon) tempPolygon.setMap(null);
                    if (window.tempPolyline2) {
                        window.tempPolyline2.setMap(null);
                        window.tempPolyline2 = null;
                    }
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        // Start drawing roof-parallel PV area with interactive rectangle
        function startDrawingRoofParallel() {
            // Clear any existing drawing mode
            drawingManager.setDrawingMode(null);
            
            // Create initial rectangle using drawing manager
            drawingManager.setDrawingMode(google.maps.drawing.OverlayType.RECTANGLE);
            drawingManager.setOptions({
                rectangleOptions: {
                    fillColor: '#4274a5',
                    fillOpacity: 0.3,
                    strokeWeight: 2,
                    strokeColor: '#4274a5',
                    editable: false,
                    draggable: false
                }
            });
            
            // One-time listener for rectangle completion
            const rectangleListener = google.maps.event.addListener(drawingManager, 'rectanglecomplete', function(rectangle) {
                google.maps.event.removeListener(rectangleListener);
                drawingManager.setDrawingMode(null);
                
                // Convert rectangle to custom roof parallel editor
                createRoofParallelEditor(rectangle);
            });
        }
        
        // Create custom roof parallel editor from rectangle
        function createRoofParallelEditor(rectangle) {
            const bounds = rectangle.getBounds();
            rectangle.setMap(null); // Remove original rectangle
            
            // Create custom polygon with colored edges
            const ne = bounds.getNorthEast();
            const nw = new google.maps.LatLng(ne.lat(), bounds.getSouthWest().lng());
            const sw = bounds.getSouthWest();
            const se = new google.maps.LatLng(sw.lat(), ne.lng());
            
            // Main polygon
            const polygon = new google.maps.Polygon({
                paths: [nw, ne, se, sw],
                fillColor: '#4274a5',
                fillOpacity: 0.3,
                strokeWeight: 2,
                strokeColor: '#4274a5',
                strokeOpacity: 0.8,
                map: map,
                draggable: true
            });
            
            // Colored edge lines
            const topEdge = new google.maps.Polyline({
                path: [nw, ne],
                strokeColor: '#2196F3', // Blue
                strokeWeight: 4,
                strokeOpacity: 0.8,
                map: map
            });
            
            const bottomEdge = new google.maps.Polyline({
                path: [sw, se],
                strokeColor: '#FF9800', // Orange
                strokeWeight: 4,
                strokeOpacity: 0.8,
                map: map
            });
            
            const leftEdge = new google.maps.Polyline({
                path: [nw, sw],
                strokeColor: '#666666',
                strokeWeight: 2,
                strokeOpacity: 0.6,
                map: map
            });
            
            const rightEdge = new google.maps.Polyline({
                path: [ne, se],
                strokeColor: '#666666',
                strokeWeight: 2,
                strokeOpacity: 0.6,
                map: map
            });
            
            // Control markers for resizing
            const markers = {
                nw: createControlMarker(nw, 'nw'),
                ne: createControlMarker(ne, 'ne'),
                sw: createControlMarker(sw, 'sw'),
                se: createControlMarker(se, 'se'),
                topMid: createControlMarker(getMidpoint(nw, ne), 'top'),
                bottomMid: createControlMarker(getMidpoint(sw, se), 'bottom')
            };
            
            // Store editor reference
            roofParallelEditor = {
                polygon: polygon,
                edges: { top: topEdge, bottom: bottomEdge, left: leftEdge, right: rightEdge },
                markers: markers,
                updateGeometry: function() {
                    const path = polygon.getPath();
                    const points = [];
                    for (let i = 0; i < path.getLength(); i++) {
                        points.push(path.getAt(i));
                    }
                    
                    // Update edge lines
                    topEdge.setPath([points[0], points[1]]);
                    bottomEdge.setPath([points[3], points[2]]);
                    leftEdge.setPath([points[0], points[3]]);
                    rightEdge.setPath([points[1], points[2]]);
                    
                    // Update control markers
                    markers.topMid.setPosition(getMidpoint(points[0], points[1]));
                    markers.bottomMid.setPosition(getMidpoint(points[3], points[2]));
                }
            };
            
            // Add drag listeners to polygon
            google.maps.event.addListener(polygon, 'drag', function() {
                roofParallelEditor.updateGeometry();
            });
            
            // Add completion buttons
            showRoofParallelControls();
            
            // Setup marker drag handlers
            setupMarkerHandlers();
            
            // Add ESC key handler
            const escHandler = function(e) {
                if (e.key === 'Escape' && roofParallelEditor) {
                    // Remove all components
                    roofParallelEditor.polygon.setMap(null);
                    Object.values(roofParallelEditor.edges).forEach(edge => edge.setMap(null));
                    Object.values(roofParallelEditor.markers).forEach(marker => marker.setMap(null));
                    roofParallelEditor = null;
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        // Create control marker
        function createControlMarker(position, type) {
            const marker = new google.maps.Marker({
                position: position,
                map: map,
                draggable: true,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: type.includes('Mid') ? '#FFC107' : '#FFFFFF',
                    fillOpacity: 1,
                    strokeColor: '#333333',
                    strokeWeight: 2
                },
                zIndex: 999
            });
            marker.type = type;
            return marker;
        }
        
        // Get midpoint between two LatLng points
        function getMidpoint(p1, p2) {
            return new google.maps.LatLng(
                (p1.lat() + p2.lat()) / 2,
                (p1.lng() + p2.lng()) / 2
            );
        }
        
        // Setup marker drag handlers
        function setupMarkerHandlers() {
            const editor = roofParallelEditor;
            const polygon = editor.polygon;
            const markers = editor.markers;
            
            // Corner markers - maintain parallelogram shape
            ['nw', 'ne', 'sw', 'se'].forEach(corner => {
                google.maps.event.addListener(markers[corner], 'drag', function(e) {
                    const path = polygon.getPath();
                    const newPos = e.latLng;
                    
                    switch(corner) {
                        case 'nw':
                            path.setAt(0, newPos);
                            path.setAt(1, new google.maps.LatLng(newPos.lat(), path.getAt(1).lng()));
                            path.setAt(3, new google.maps.LatLng(path.getAt(3).lat(), newPos.lng()));
                            markers.ne.setPosition(path.getAt(1));
                            markers.sw.setPosition(path.getAt(3));
                            break;
                        case 'ne':
                            path.setAt(1, newPos);
                            path.setAt(0, new google.maps.LatLng(newPos.lat(), path.getAt(0).lng()));
                            path.setAt(2, new google.maps.LatLng(path.getAt(2).lat(), newPos.lng()));
                            markers.nw.setPosition(path.getAt(0));
                            markers.se.setPosition(path.getAt(2));
                            break;
                        case 'sw':
                            path.setAt(3, newPos);
                            path.setAt(0, new google.maps.LatLng(path.getAt(0).lat(), newPos.lng()));
                            path.setAt(2, new google.maps.LatLng(newPos.lat(), path.getAt(2).lng()));
                            markers.nw.setPosition(path.getAt(0));
                            markers.se.setPosition(path.getAt(2));
                            break;
                        case 'se':
                            path.setAt(2, newPos);
                            path.setAt(1, new google.maps.LatLng(path.getAt(1).lat(), newPos.lng()));
                            path.setAt(3, new google.maps.LatLng(newPos.lat(), path.getAt(3).lng()));
                            markers.ne.setPosition(path.getAt(1));
                            markers.sw.setPosition(path.getAt(3));
                            break;
                    }
                    
                    editor.updateGeometry();
                });
            });
            
            // Edge midpoint markers - parallel movement
            google.maps.event.addListener(markers.topMid, 'drag', function(e) {
                const path = polygon.getPath();
                const oldLat = markers.topMid.getPosition().lat();
                const newLat = e.latLng.lat();
                const latDiff = newLat - oldLat;
                
                path.setAt(0, new google.maps.LatLng(path.getAt(0).lat() + latDiff, path.getAt(0).lng()));
                path.setAt(1, new google.maps.LatLng(path.getAt(1).lat() + latDiff, path.getAt(1).lng()));
                
                markers.nw.setPosition(path.getAt(0));
                markers.ne.setPosition(path.getAt(1));
                editor.updateGeometry();
            });
            
            google.maps.event.addListener(markers.bottomMid, 'drag', function(e) {
                const path = polygon.getPath();
                const oldLat = markers.bottomMid.getPosition().lat();
                const newLat = e.latLng.lat();
                const latDiff = newLat - oldLat;
                
                path.setAt(2, new google.maps.LatLng(path.getAt(2).lat() + latDiff, path.getAt(2).lng()));
                path.setAt(3, new google.maps.LatLng(path.getAt(3).lat() + latDiff, path.getAt(3).lng()));
                
                markers.se.setPosition(path.getAt(2));
                markers.sw.setPosition(path.getAt(3));
                editor.updateGeometry();
            });
        }
        
        // Show control buttons for roof parallel editor
        function showRoofParallelControls() {
            // Don't show controls - the shape is directly editable
            // Just add double-click listener to finalize
            if (roofParallelEditor && roofParallelEditor.polygon) {
                google.maps.event.addListener(roofParallelEditor.polygon, 'dblclick', function() {
                    acceptRoofParallel();
                });
            }
        }
        
        // Accept roof parallel area
        function acceptRoofParallel() {
            if (roofParallelEditor) {
                const polygon = roofParallelEditor.polygon;
                const path = polygon.getPath();
                
                // Clean up editing interface
                Object.values(roofParallelEditor.edges).forEach(edge => edge.setMap(null));
                Object.values(roofParallelEditor.markers).forEach(marker => marker.setMap(null));
                
                // Update polygon to final style
                polygon.setOptions({
                    fillColor: '#4274a5',
                    fillOpacity: 0.4,
                    strokeWeight: 2,
                    strokeColor: '#4274a5',
                    editable: true,
                    draggable: true
                });
                
                // Handle as completed PV area
                handlePVAreaComplete(polygon);
                
                roofParallelEditor = null;
            }
        }
        
        function startDrawingOP() {
            drawingManager.setDrawingMode(google.maps.drawing.OverlayType.MARKER);
        }
        
        // Enhance polygon with better editing capabilities
        function enhancePolygonEditing(polygon, enableEnhanced = false, editingMode = 'standard') {
            const path = polygon.getPath();
            const markers = [];
            const midpointMarkers = [];
            
            // Store enhancement flags on the polygon itself
            polygon.isEnhanced = enableEnhanced;
            polygon.editingMode = editingMode;
            polygon.isRoofArea = editingMode === 'roof-parallel'; // Only true for roof-parallel
            
            // Store all associated elements on the polygon for cleanup
            polygon.associatedElements = {
                markers: markers,
                midpointMarkers: midpointMarkers,
                edgeMoveMarkers: [],
                edgeLines: [],
                rotationMarker: null,
                azimuthArrow: null,
                azimuthLabel: null
            };
            
            // Create vertex markers
            function createVertexMarkers() {
                // Clear existing markers
                markers.forEach(m => {
                    if (m.doubleArrowMarker) {
                        m.doubleArrowMarker.setMap(null);
                    }
                    m.setMap(null);
                });
                markers.length = 0;
                
                // Always get the current path from the polygon
                const currentPath = polygon.getPath();
                
                // Create marker for each vertex
                currentPath.forEach((vertex, index) => {
                    const marker = new google.maps.Marker({
                        position: vertex,
                        map: map,
                        draggable: true,
                        label: polygon.isEnhanced ? {
                            text: (index + 1).toString(),
                            color: '#FFFFFF',
                            fontSize: '14px',
                            fontWeight: 'bold'
                        } : null,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 4,
                            fillColor: '#FFFFFF',
                            fillOpacity: 1,
                            strokeColor: '#000000',
                            strokeWeight: 2,
                            labelOrigin: polygon.isEnhanced ? new google.maps.Point(0, -4) : undefined
                        },
                        zIndex: 1000
                    });
                    
                    // For roof areas, store the initial edge direction and create double arrow
                    let edgeDirection = null;
                    let doubleArrowMarker = null;
                    
                    if (polygon.editingMode === 'roof-parallel') {
                        // P0-P1 and P2-P3 are the parallel edges - only for roof-parallel
                        const otherIndex = (index === 0) ? 1 : (index === 1) ? 0 : (index === 2) ? 3 : 2;
                        const p1 = currentPath.getAt(index);
                        const p2 = currentPath.getAt(otherIndex);
                        edgeDirection = {
                            lat: p2.lat() - p1.lat(),
                            lng: p2.lng() - p1.lng()
                        };
                        // Normalize the direction vector
                        const length = Math.sqrt(edgeDirection.lat * edgeDirection.lat + edgeDirection.lng * edgeDirection.lng);
                        edgeDirection.lat /= length;
                        edgeDirection.lng /= length;
                        
                        // Calculate rotation angle for the double arrow
                        // Google Maps rotation: 0° = North, clockwise positive
                        // We want the arrow to point along the edge direction
                        // Add 90° because our arrow SVG points East-West by default
                        const angle = Math.atan2(edgeDirection.lng, edgeDirection.lat) * 180 / Math.PI + 90;
                        
                        // Create double arrow marker below the vertex
                        doubleArrowMarker = new google.maps.Marker({
                            position: vertex,
                            map: map,
                            icon: {
                                path: 'M -15,0 L -10,-3 L -10,-1 L 10,-1 L 10,-3 L 15,0 L 10,3 L 10,1 L -10,1 L -10,3 Z',
                                scale: 0.8,
                                fillColor: '#666666',
                                fillOpacity: 0.7,
                                strokeColor: '#FFFFFF',
                                strokeWeight: 1,
                                rotation: angle,
                                anchor: new google.maps.Point(0, 0) // Center on vertex
                            },
                            clickable: false,
                            zIndex: 997
                        });
                    }
                    
                    // Update polygon vertex when marker is dragged
                    google.maps.event.addListener(marker, 'drag', function(e) {
                        // For roof areas, constrain movement along original edge direction
                        if (polygon.isRoofArea && currentPath.getLength() === 4 && edgeDirection) {
                            const newPos = e.latLng;
                            const currentPos = currentPath.getAt(index);
                            
                            // Project the new position onto the edge direction
                            const delta = {
                                lat: newPos.lat() - currentPos.lat(),
                                lng: newPos.lng() - currentPos.lng()
                            };
                            
                            // Dot product to get projection length
                            const projectionLength = delta.lat * edgeDirection.lat + delta.lng * edgeDirection.lng;
                            
                            // Calculate constrained position
                            const constrainedPos = new google.maps.LatLng(
                                currentPos.lat() + projectionLength * edgeDirection.lat,
                                currentPos.lng() + projectionLength * edgeDirection.lng
                            );
                            
                            // Update only this vertex
                            polygon.getPath().setAt(index, constrainedPos);
                            marker.setPosition(constrainedPos);
                            
                            // Update double arrow position
                            if (marker.doubleArrowMarker) {
                                marker.doubleArrowMarker.setPosition(constrainedPos);
                            }
                            
                            // Update edge marker positions and edge lines
                            if (edgeMoveMarkers.length > 0) {
                                const polygonPath = polygon.getPath();
                                const midpoint12 = new google.maps.LatLng(
                                    (polygonPath.getAt(0).lat() + polygonPath.getAt(1).lat()) / 2,
                                    (polygonPath.getAt(0).lng() + polygonPath.getAt(1).lng()) / 2
                                );
                                const midpoint34 = new google.maps.LatLng(
                                    (polygonPath.getAt(2).lat() + polygonPath.getAt(3).lat()) / 2,
                                    (polygonPath.getAt(2).lng() + polygonPath.getAt(3).lng()) / 2
                                );
                                if (edgeMoveMarkers[0]) edgeMoveMarkers[0].setPosition(midpoint12);
                                if (edgeMoveMarkers[1]) edgeMoveMarkers[1].setPosition(midpoint34);
                                
                                // Update edge lines
                                if (edgeLines.length >= 2) {
                                    edgeLines[0].setPath([polygonPath.getAt(0), polygonPath.getAt(1)]);
                                    edgeLines[1].setPath([polygonPath.getAt(2), polygonPath.getAt(3)]);
                                }
                            }
                        } else {
                            // Normal behavior for non-roof areas
                            polygon.getPath().setAt(index, e.latLng);
                        }
                        updateMidpointMarkers();
                        
                        // Update dimensions if shown
                        if (polygon.pvAreaData) {
                            updatePVDimensions(polygon.pvAreaData);
                        }
                    });
                    
                    // Prevent marker from jumping on drag end for roof areas
                    google.maps.event.addListener(marker, 'dragend', function(e) {
                        if (polygon.isRoofArea && polygon.getPath().getLength() === 4) {
                            // Force marker back to its constrained position
                            const constrainedPos = polygon.getPath().getAt(index);
                            marker.setPosition(constrainedPos);
                        }
                    });
                    
                    markers.push(marker);
                    
                    // Store the double arrow marker with the vertex marker
                    if (doubleArrowMarker) {
                        marker.doubleArrowMarker = doubleArrowMarker;
                    }
                });
                
                updateMidpointMarkers();
            }
            
            // Create midpoint markers for adding new vertices
            function updateMidpointMarkers() {
                // Clear existing midpoint markers
                midpointMarkers.forEach(m => m.setMap(null));
                midpointMarkers.length = 0;
                
                // Skip midpoint markers only for roof-parallel (they use edge markers instead)
                if (polygon.editingMode === 'roof-parallel') return;
                
                const currentPath = polygon.getPath();
                
                // Create midpoint marker between each pair of vertices
                for (let i = 0; i < currentPath.getLength(); i++) {
                    const nextIndex = (i + 1) % currentPath.getLength();
                    const midpoint = new google.maps.LatLng(
                        (currentPath.getAt(i).lat() + currentPath.getAt(nextIndex).lat()) / 2,
                        (currentPath.getAt(i).lng() + currentPath.getAt(nextIndex).lng()) / 2
                    );
                    
                    const midMarker = new google.maps.Marker({
                        position: midpoint,
                        map: map,
                        draggable: true,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 4,
                            fillColor: '#FFC107',
                            fillOpacity: 0.8,
                            strokeColor: '#F57C00',
                            strokeWeight: 1
                        },
                        zIndex: 999
                    });
                    
                    // When midpoint is dragged, insert new vertex
                    midMarker.index = i;
                    google.maps.event.addListener(midMarker, 'dragstart', function(e) {
                        // Insert new vertex at this position
                        polygon.getPath().insertAt(this.index + 1, e.latLng);
                        createVertexMarkers(); // Recreate all markers
                    });
                    
                    midpointMarkers.push(midMarker);
                }
            }
            
            // Show/hide edit markers based on polygon state
            let editMode = false;
            
            // Create edge move markers for roof areas
            const edgeMoveMarkers = polygon.associatedElements.edgeMoveMarkers;
            const edgeLines = polygon.associatedElements.edgeLines;
            let rotationMarker = polygon.associatedElements.rotationMarker;
            let azimuthArrow = polygon.associatedElements.azimuthArrow;
            let azimuthLabel = polygon.associatedElements.azimuthLabel;
            
            function createEdgeMoveMarkers() {
                // Clear existing edge markers
                edgeMoveMarkers.forEach(m => m.setMap(null));
                edgeMoveMarkers.length = 0;
                
                // Clear existing edge lines
                edgeLines.forEach(l => l.setMap(null));
                edgeLines.length = 0;
                
                // Clear rotation marker
                if (rotationMarker) {
                    rotationMarker.setMap(null);
                    rotationMarker = null;
                }
                
                const currentPath = polygon.getPath();
                if (polygon.editingMode !== 'roof-parallel' || currentPath.getLength() !== 4) return;
                
                // Create marker for P1-P2 edge (index 0)
                const p1 = currentPath.getAt(0);
                const p2 = currentPath.getAt(1);
                const midpoint12 = new google.maps.LatLng(
                    (p1.lat() + p2.lat()) / 2,
                    (p1.lng() + p2.lng()) / 2
                );
                
                const edgeMarker1 = new google.maps.Marker({
                    position: midpoint12,
                    map: map,
                    draggable: true,
                    icon: {
                        path: 'M 0,-10 L -3,-7 L -1,-7 L -1,-1 L -7,-1 L -7,-3 L -10,0 L -7,3 L -7,1 L -1,1 L -1,7 L -3,7 L 0,10 L 3,7 L 1,7 L 1,1 L 7,1 L 7,3 L 10,0 L 7,-3 L 7,-1 L 1,-1 L 1,-7 L 3,-7 Z',
                        scale: 0.8,
                        fillColor: '#4274a5',
                        fillOpacity: 0.8,
                        strokeColor: '#FFFFFF',
                        strokeWeight: 1
                    },
                    cursor: 'move',
                    zIndex: 999
                });
                
                // Create marker for P3-P4 edge (index 1)
                const p3 = currentPath.getAt(2);
                const p4 = currentPath.getAt(3);
                const midpoint34 = new google.maps.LatLng(
                    (p3.lat() + p4.lat()) / 2,
                    (p3.lng() + p4.lng()) / 2
                );
                
                const edgeMarker2 = new google.maps.Marker({
                    position: midpoint34,
                    map: map,
                    draggable: true,
                    icon: {
                        path: 'M 0,-10 L -3,-7 L -1,-7 L -1,-1 L -7,-1 L -7,-3 L -10,0 L -7,3 L -7,1 L -1,1 L -1,7 L -3,7 L 0,10 L 3,7 L 1,7 L 1,1 L 7,1 L 7,3 L 10,0 L 7,-3 L 7,-1 L 1,-1 L 1,-7 L 3,-7 Z',
                        scale: 0.8,
                        fillColor: '#4274a5',
                        fillOpacity: 0.8,
                        strokeColor: '#FFFFFF',
                        strokeWeight: 1
                    },
                    cursor: 'move',
                    zIndex: 999
                });
                
                // Add drag listeners for edge markers
                setupEdgeMarkerDrag(edgeMarker1, 0, 1);
                setupEdgeMarkerDrag(edgeMarker2, 2, 3);
                
                edgeMoveMarkers.push(edgeMarker1, edgeMarker2);
                
                // Create colored edge lines
                // P1-P2 edge in turquoise
                const edge12 = new google.maps.Polyline({
                    path: [p1, p2],
                    strokeColor: '#00CED1',  // Turquoise
                    strokeWeight: 4,
                    strokeOpacity: 0.8,
                    map: map,
                    clickable: false,
                    zIndex: 995
                });
                
                // P3-P4 edge in orange
                const edge34 = new google.maps.Polyline({
                    path: [p3, p4],
                    strokeColor: '#FF8C00',  // Orange
                    strokeWeight: 4,
                    strokeOpacity: 0.8,
                    map: map,
                    clickable: false,
                    zIndex: 995
                });
                
                edgeLines.push(edge12, edge34);
                
                // Create rotation marker in center
                const center = new google.maps.LatLng(
                    (p1.lat() + p2.lat() + p3.lat() + p4.lat()) / 4,
                    (p1.lng() + p2.lng() + p3.lng() + p4.lng()) / 4
                );
                
                rotationMarker = new google.maps.Marker({
                    position: center,
                    map: map,
                    icon: {
                        path: 'M -8,0 A 8,8 0 0,1 0,-8 M 0,-8 L 2,-10 L 0,-6 L -2,-10 L 0,-8 M 8,0 A 8,8 0 0,1 0,8 M 0,8 L -2,10 L 0,6 L 2,10 L 0,8',
                        scale: 0.8,
                        fillColor: 'transparent',
                        fillOpacity: 0,
                        strokeColor: '#FFFFFF',
                        strokeWeight: 2.5,
                        anchor: new google.maps.Point(0, 0)
                    },
                    cursor: 'grab',
                    zIndex: 998
                });
                
                // Store in polygon's associated elements
                polygon.associatedElements.rotationMarker = rotationMarker;
                
                
                // Setup rotation handling
                setupRotationHandler();
            }
            
            function setupEdgeMarkerDrag(marker, idx1, idx2) {
                let dragStartPos;
                
                google.maps.event.addListener(marker, 'dragstart', function(e) {
                    dragStartPos = marker.getPosition();
                });
                
                google.maps.event.addListener(marker, 'drag', function(e) {
                    const newPos = e.latLng;
                    const displacement = {
                        lat: newPos.lat() - dragStartPos.lat(),
                        lng: newPos.lng() - dragStartPos.lng()
                    };
                    
                    const currentPath = polygon.getPath();
                    
                    // Move both points of the edge
                    const p1 = currentPath.getAt(idx1);
                    const p2 = currentPath.getAt(idx2);
                    
                    const newP1 = new google.maps.LatLng(
                        p1.lat() + displacement.lat,
                        p1.lng() + displacement.lng
                    );
                    const newP2 = new google.maps.LatLng(
                        p2.lat() + displacement.lat,
                        p2.lng() + displacement.lng
                    );
                    
                    currentPath.setAt(idx1, newP1);
                    currentPath.setAt(idx2, newP2);
                    
                    // Update vertex markers if they exist
                    if (markers[idx1]) {
                        markers[idx1].setPosition(newP1);
                        // Update double arrow position
                        if (markers[idx1].doubleArrowMarker) {
                            markers[idx1].doubleArrowMarker.setPosition(newP1);
                        }
                    }
                    if (markers[idx2]) {
                        markers[idx2].setPosition(newP2);
                        // Update double arrow position
                        if (markers[idx2].doubleArrowMarker) {
                            markers[idx2].doubleArrowMarker.setPosition(newP2);
                        }
                    }
                    
                    // Update edge marker position
                    const newMidpoint = new google.maps.LatLng(
                        (newP1.lat() + newP2.lat()) / 2,
                        (newP1.lng() + newP2.lng()) / 2
                    );
                    marker.setPosition(newMidpoint);
                    
                    // Update edge lines
                    if (edgeLines.length >= 2) {
                        if (idx1 === 0) {
                            // Update P1-P2 edge line
                            edgeLines[0].setPath([newP1, newP2]);
                        } else if (idx1 === 2) {
                            // Update P3-P4 edge line
                            edgeLines[1].setPath([newP1, newP2]);
                        }
                    }
                    
                    dragStartPos = newMidpoint;
                    
                    // Update dimensions if shown
                    if (polygon.pvAreaData) {
                        updatePVDimensions(polygon.pvAreaData);
                    }
                });
                
                google.maps.event.addListener(marker, 'dragend', function(e) {
                    // Update other edge marker position
                    createEdgeMoveMarkers();
                    
                    // Update perpendicular distance and dimensions
                    if (polygon.pvAreaData) {
                        if (polygon.pvAreaData.type === 'roof-parallel') {
                            polygon.pvAreaData.perpendicularDistance = calculatePerpendicularDistance(polygon);
                            // Recalculate azimuth if auto-calculate is enabled
                            if (polygon.pvAreaData.autoCalculateAzimuth) {
                                polygon.pvAreaData.azimuth = calculatePVAreaAzimuth(polygon);
                            }
                            // Recalculate auto-field if enabled
                            if (polygon.pvAreaData.autoCalculateField) {
                                calculateAutoField(polygon.pvAreaData);
                            }
                            updateUI(); // Update distance display
                        }
                        updatePVDimensions(polygon.pvAreaData);
                    }
                });
            }
            
            // Setup rotation handling
            function setupRotationHandler() {
                if (!rotationMarker || !polygon.isRoofArea) return;
                
                let isDragging = false;
                let initialAzimuth = polygon.pvAreaData ? polygon.pvAreaData.azimuth : 180;
                let originalPoints = [];
                let originalCenter = null;
                let startAngle = 0;
                let currentRotation = 0;
                let initialGeometricAzimuth = 0;
                let initialMouseAzimuth = 0;
                
                // Calculate the geometric azimuth (orthogonal to P1-P2, pointing towards P3-P4)
                function calculateGeometricAzimuth() {
                    const currentPath = polygon.getPath();
                    const p1 = currentPath.getAt(0);
                    const p2 = currentPath.getAt(1);
                    const p3 = currentPath.getAt(2);
                    const p4 = currentPath.getAt(3);
                    
                    // Simple approach: PV azimuth is the bearing of the normal to the first edge
                    // The normal points from the first edge (P1-P2) towards the opposite edge
                    
                    // Calculate bearing from P1 to P2
                    const lat1 = p1.lat() * Math.PI / 180;
                    const lat2 = p2.lat() * Math.PI / 180;
                    const dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
                    
                    // Calculate bearing using the forward azimuth formula
                    const y = Math.sin(dLon) * Math.cos(lat2);
                    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
                    
                    let bearingP1P2 = Math.atan2(y, x) * 180 / Math.PI;
                    bearingP1P2 = (bearingP1P2 + 360) % 360;
                    
                    // For a roof installation, we need to determine which way is "up" (towards ridge)
                    // Check which perpendicular direction points towards P3/P4
                    
                    // Get center of P1-P2 edge
                    const centerP1P2 = {
                        lat: (p1.lat() + p2.lat()) / 2,
                        lng: (p1.lng() + p2.lng()) / 2
                    };
                    
                    // Get center of P3-P4 edge
                    const centerP3P4 = {
                        lat: (p3.lat() + p4.lat()) / 2,
                        lng: (p3.lng() + p4.lng()) / 2
                    };
                    
                    // Calculate bearing from center of P1-P2 to center of P3-P4
                    const latC1 = centerP1P2.lat * Math.PI / 180;
                    const latC2 = centerP3P4.lat * Math.PI / 180;
                    const dLonC = (centerP3P4.lng - centerP1P2.lng) * Math.PI / 180;
                    
                    const yC = Math.sin(dLonC) * Math.cos(latC2);
                    const xC = Math.cos(latC1) * Math.sin(latC2) - Math.sin(latC1) * Math.cos(latC2) * Math.cos(dLonC);
                    
                    let bearingToOpposite = Math.atan2(yC, xC) * 180 / Math.PI;
                    bearingToOpposite = (bearingToOpposite + 360) % 360;
                    
                    // The two possible perpendiculars to P1-P2
                    const perpendicular1 = (bearingP1P2 + 90) % 360;
                    const perpendicular2 = (bearingP1P2 - 90 + 360) % 360;
                    
                    // Calculate angular difference (handling wrap-around)
                    const diff1 = Math.abs(((perpendicular1 - bearingToOpposite + 540) % 360) - 180);
                    const diff2 = Math.abs(((perpendicular2 - bearingToOpposite + 540) % 360) - 180);
                    
                    // Choose the perpendicular that points more towards the opposite edge
                    const azimuth = diff1 < diff2 ? perpendicular1 : perpendicular2;
                    
                    console.log('P1->P2 bearing:', bearingP1P2);
                    console.log('Bearing to opposite:', bearingToOpposite);
                    console.log('Perpendicular 1:', perpendicular1, 'diff:', diff1);
                    console.log('Perpendicular 2:', perpendicular2, 'diff:', diff2);
                    console.log('Chosen azimuth:', azimuth);
                    
                    return azimuth;
                }
                
                google.maps.event.addListener(rotationMarker, 'mousedown', function(e) {
                    isDragging = true;
                    rotationMarker.setOptions({ cursor: 'grabbing' });
                    
                    // Save original points and center
                    originalPoints = [];
                    const currentPath = polygon.getPath();
                    for (let i = 0; i < 4; i++) {
                        originalPoints.push({
                            lat: currentPath.getAt(i).lat(),
                            lng: currentPath.getAt(i).lng()
                        });
                    }
                    
                    originalCenter = {
                        lat: rotationMarker.getPosition().lat(),
                        lng: rotationMarker.getPosition().lng()
                    };
                    
                    // Hide rotation symbol and show arrow
                    rotationMarker.setVisible(false);
                    
                    // Create azimuth arrow
                    const center = rotationMarker.getPosition();
                    
                    // Set start angle to current mouse position
                    startAngle = Math.atan2(e.latLng.lat() - center.lat(), e.latLng.lng() - center.lng());
                    currentRotation = 0;
                    
                    // Calculate the initial azimuth of the PV area ONCE at start of drag
                    initialGeometricAzimuth = calculateGeometricAzimuth();
                    const currentAzimuth = initialGeometricAzimuth;
                    
                    // Store the initial angle from center to mouse
                    const initialMouseLat1 = originalCenter.lat * Math.PI / 180;
                    const initialMouseLat2 = e.latLng.lat() * Math.PI / 180;
                    const initialMouseDLon = (e.latLng.lng() - originalCenter.lng) * Math.PI / 180;
                    
                    const initialMouseY = Math.sin(initialMouseDLon) * Math.cos(initialMouseLat2);
                    const initialMouseX = Math.cos(initialMouseLat1) * Math.sin(initialMouseLat2) - Math.sin(initialMouseLat1) * Math.cos(initialMouseLat2) * Math.cos(initialMouseDLon);
                    
                    let initialMouseAzimuth = Math.atan2(initialMouseY, initialMouseX) * 180 / Math.PI;
                    initialMouseAzimuth = (initialMouseAzimuth + 360) % 360;
                    
                    // Calculate initial arrow end point based on current azimuth
                    const arrowLength = google.maps.geometry.spherical.computeDistanceBetween(center, e.latLng);
                    const initialArrowEnd = google.maps.geometry.spherical.computeOffset(center, arrowLength, currentAzimuth);
                    
                    azimuthArrow = new google.maps.Polyline({
                        path: [center, initialArrowEnd],
                        strokeColor: '#FF0000',
                        strokeWeight: 3,
                        strokeOpacity: 0.8,
                        map: map,
                        zIndex: 999,
                        icons: [{
                            icon: {
                                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                                scale: 4,
                                fillColor: '#FF0000',
                                fillOpacity: 0.8,
                                strokeColor: '#FFFFFF',
                                strokeWeight: 1
                            },
                            offset: '100%'
                        }]
                    });
                    
                    // Store in polygon's associated elements
                    polygon.associatedElements.azimuthArrow = azimuthArrow;
                    
                    // Create azimuth label with pixel-based offset
                    azimuthLabel = new google.maps.Marker({
                        position: initialArrowEnd,
                        map: map,
                        label: {
                            text: currentAzimuth.toFixed(1) + '°',
                            color: '#FFFFFF',
                            fontSize: '18px',
                            fontWeight: 'bold',
                            fontFamily: 'Arial, sans-serif'
                        },
                        icon: {
                            path: 'M -30,-10 L 30,-10 L 30,10 L -30,10 Z',
                            fillColor: '#000000',
                            fillOpacity: 0.7,
                            strokeColor: '#000000',
                            strokeWeight: 3,
                            scale: 1,
                            labelOrigin: new google.maps.Point(0, 0),
                            anchor: new google.maps.Point(-40, -20) // Pixel offset: 40px right, 20px up
                        },
                        zIndex: 1000
                    });
                    
                    // Store in polygon's associated elements
                    polygon.associatedElements.azimuthLabel = azimuthLabel;
                    
                    e.stop();
                });
                
                // Mouse move handler
                google.maps.event.addListener(map, 'mousemove', function(e) {
                    if (isDragging && azimuthArrow && azimuthLabel && originalCenter) {
                        const centerLatLng = new google.maps.LatLng(originalCenter.lat, originalCenter.lng);
                        
                        // Calculate the desired azimuth from center to mouse
                        const mouseLat1 = originalCenter.lat * Math.PI / 180;
                        const mouseLat2 = e.latLng.lat() * Math.PI / 180;
                        const mouseDLon = (e.latLng.lng() - originalCenter.lng) * Math.PI / 180;
                        
                        const mouseY = Math.sin(mouseDLon) * Math.cos(mouseLat2);
                        const mouseX = Math.cos(mouseLat1) * Math.sin(mouseLat2) - Math.sin(mouseLat1) * Math.cos(mouseLat2) * Math.cos(mouseDLon);
                        
                        let desiredAzimuth = Math.atan2(mouseY, mouseX) * 180 / Math.PI;
                        desiredAzimuth = (desiredAzimuth + 360) % 360;
                        
                        // Work in pixel space for accurate rotation
                        const projection = map.getProjection();
                        const zoom = map.getZoom();
                        const scale = Math.pow(2, zoom);
                        
                        // Convert center and mouse to pixel coordinates
                        const centerPixel = projection.fromLatLngToPoint(centerLatLng);
                        const mousePixel = projection.fromLatLngToPoint(e.latLng);
                        centerPixel.x *= scale; centerPixel.y *= scale;
                        mousePixel.x *= scale; mousePixel.y *= scale;
                        
                        // Calculate desired direction in pixel space
                        const desiredDirPixel = {
                            x: mousePixel.x - centerPixel.x,
                            y: mousePixel.y - centerPixel.y
                        };
                        const desiredDirLength = Math.sqrt(desiredDirPixel.x * desiredDirPixel.x + desiredDirPixel.y * desiredDirPixel.y);
                        desiredDirPixel.x /= desiredDirLength;
                        desiredDirPixel.y /= desiredDirLength;
                        
                        // Convert original points to pixel space
                        const originalPixelPoints = originalPoints.map(p => {
                            const pixel = projection.fromLatLngToPoint(new google.maps.LatLng(p.lat, p.lng));
                            return { x: pixel.x * scale, y: pixel.y * scale };
                        });
                        
                        // Calculate initial w direction in pixel space
                        const v0Pixel = {
                            x: originalPixelPoints[1].x - originalPixelPoints[0].x,
                            y: originalPixelPoints[1].y - originalPixelPoints[0].y
                        };
                        const d0Pixel = {
                            x: originalPixelPoints[2].x - originalPixelPoints[0].x,
                            y: originalPixelPoints[2].y - originalPixelPoints[0].y
                        };
                        
                        // Project d onto v to get w
                        const dot0 = d0Pixel.x * v0Pixel.x + d0Pixel.y * v0Pixel.y;
                        const v0LengthSq = v0Pixel.x * v0Pixel.x + v0Pixel.y * v0Pixel.y;
                        const proj0 = { x: (dot0 / v0LengthSq) * v0Pixel.x, y: (dot0 / v0LengthSq) * v0Pixel.y };
                        const w0Pixel = { x: d0Pixel.x - proj0.x, y: d0Pixel.y - proj0.y };
                        const w0Length = Math.sqrt(w0Pixel.x * w0Pixel.x + w0Pixel.y * w0Pixel.y);
                        w0Pixel.x /= w0Length;
                        w0Pixel.y /= w0Length;
                        
                        // Calculate rotation angle in pixel space
                        const crossProduct = w0Pixel.x * desiredDirPixel.y - w0Pixel.y * desiredDirPixel.x;
                        const dotProduct = w0Pixel.x * desiredDirPixel.x + w0Pixel.y * desiredDirPixel.y;
                        const rotationAngle = Math.atan2(crossProduct, dotProduct);
                        
                        // Apply rotation in pixel space
                        const cosR = Math.cos(rotationAngle);
                        const sinR = Math.sin(rotationAngle);
                        
                        for (let i = 0; i < 4; i++) {
                            const dx = originalPixelPoints[i].x - centerPixel.x;
                            const dy = originalPixelPoints[i].y - centerPixel.y;
                            
                            const rotatedX = dx * cosR - dy * sinR + centerPixel.x;
                            const rotatedY = dx * sinR + dy * cosR + centerPixel.y;
                            
                            // Convert back to lat/lng
                            const point = projection.fromPointToLatLng(new google.maps.Point(rotatedX / scale, rotatedY / scale));
                            polygon.getPath().setAt(i, point);
                        }
                        
                        // Calculate actual w vector after rotation
                        const currentPath = polygon.getPath();
                        const p1 = currentPath.getAt(0);
                        const p2 = currentPath.getAt(1);
                        const p3 = currentPath.getAt(2);
                        
                        // Calculate v (direction along edge P1-P2)
                        const v = {
                            lat: p2.lat() - p1.lat(),
                            lng: p2.lng() - p1.lng()
                        };
                        
                        // Calculate d (from P1 to P3)
                        const d = {
                            lat: p3.lat() - p1.lat(),
                            lng: p3.lng() - p1.lng()
                        };
                        
                        // Project d onto v
                        const dot_d_v = d.lat * v.lat + d.lng * v.lng;
                        const dot_v_v = v.lat * v.lat + v.lng * v.lng;
                        const scalar = dot_d_v / dot_v_v;
                        
                        const proj_d_on_v = {
                            lat: scalar * v.lat,
                            lng: scalar * v.lng
                        };
                        
                        // w = d - proj_d_on_v (actual orthogonal vector)
                        const w = {
                            lat: d.lat - proj_d_on_v.lat,
                            lng: d.lng - proj_d_on_v.lng
                        };
                        
                        // Normalize w for azimuth calculation
                        const w_length = Math.sqrt(w.lat * w.lat + w.lng * w.lng);
                        
                        // Draw arrow to mouse (should now align with w due to pixel-perfect rotation)
                        azimuthArrow.setPath([centerLatLng, e.latLng]);
                        
                        // Calculate actual azimuth from w vector
                        const actualAzimuth = Math.atan2(w.lng / w_length, w.lat / w_length) * 180 / Math.PI;
                        const normalizedAzimuth = (actualAzimuth + 360) % 360;
                        
                        // Update label at mouse
                        azimuthLabel.setPosition(e.latLng);
                        azimuthLabel.setLabel({
                            text: normalizedAzimuth.toFixed(1) + '°',
                            color: '#FFFFFF',
                            fontSize: '18px',
                            fontWeight: 'bold',
                            fontFamily: 'Arial, sans-serif'
                        });
                        
                        // Update vertex markers and their double arrows
                        if (markers.length > 0) {
                            for (let i = 0; i < 4 && i < markers.length; i++) {
                                markers[i].setPosition(currentPath.getAt(i));
                                
                                // Update double arrow if exists
                                if (markers[i].doubleArrowMarker) {
                                    markers[i].doubleArrowMarker.setPosition(currentPath.getAt(i));
                                    
                                    // Recalculate rotation for double arrow
                                    const otherIndex = (i === 0) ? 1 : (i === 1) ? 0 : (i === 2) ? 3 : 2;
                                    const p1 = currentPath.getAt(i);
                                    const p2 = currentPath.getAt(otherIndex);
                                    const edgeDir = {
                                        lat: p2.lat() - p1.lat(),
                                        lng: p2.lng() - p1.lng()
                                    };
                                    const angle = Math.atan2(edgeDir.lng, edgeDir.lat) * 180 / Math.PI + 90;
                                    
                                    markers[i].doubleArrowMarker.setOptions({
                                        icon: {
                                            path: 'M -15,0 L -10,-3 L -10,-1 L 10,-1 L 10,-3 L 15,0 L 10,3 L 10,1 L -10,1 L -10,3 Z',
                                            scale: 0.8,
                                            fillColor: '#666666',
                                            fillOpacity: 0.7,
                                            strokeColor: '#FFFFFF',
                                            strokeWeight: 1,
                                            rotation: angle,
                                            anchor: new google.maps.Point(0, 0)
                                        }
                                    });
                                }
                            }
                        }
                        
                        // Update edge lines
                        if (edgeLines.length >= 2) {
                            edgeLines[0].setPath([currentPath.getAt(0), currentPath.getAt(1)]);
                            edgeLines[1].setPath([currentPath.getAt(2), currentPath.getAt(3)]);
                        }
                        
                        // Update edge move markers
                        if (edgeMoveMarkers.length >= 2) {
                            const mid12 = new google.maps.LatLng(
                                (currentPath.getAt(0).lat() + currentPath.getAt(1).lat()) / 2,
                                (currentPath.getAt(0).lng() + currentPath.getAt(1).lng()) / 2
                            );
                            const mid34 = new google.maps.LatLng(
                                (currentPath.getAt(2).lat() + currentPath.getAt(3).lat()) / 2,
                                (currentPath.getAt(2).lng() + currentPath.getAt(3).lng()) / 2
                            );
                            edgeMoveMarkers[0].setPosition(mid12);
                            edgeMoveMarkers[1].setPosition(mid34);
                        }
                        
                        // Update the PV area azimuth with actual calculated azimuth
                        if (polygon.pvAreaData) {
                            polygon.pvAreaData.azimuth = Math.round(normalizedAzimuth * 10) / 10; // Round to 0.1°
                        }
                    }
                });
                
                // Mouse up handler - using document to catch all mouse up events
                document.addEventListener('mouseup', function(e) {
                    if (isDragging) {
                        isDragging = false;
                        rotationMarker.setOptions({ cursor: 'grab' });
                        rotationMarker.setVisible(true);
                        
                        // Clean up arrow and label
                        if (azimuthArrow) {
                            azimuthArrow.setMap(null);
                            azimuthArrow = null;
                            polygon.associatedElements.azimuthArrow = null;
                        }
                        if (azimuthLabel) {
                            azimuthLabel.setMap(null);
                            azimuthLabel = null;
                            polygon.associatedElements.azimuthLabel = null;
                        }
                        
                        // Update stored corner positions and bounds BEFORE recreating markers
                        if (polygon.pvAreaData) {
                            polygon.pvAreaData.corners = [];
                            const bounds = {
                                north: -90,
                                south: 90,
                                east: -180,
                                west: 180
                            };
                            
                            // Get the current path from the polygon
                            const currentPath = polygon.getPath();
                            
                            currentPath.forEach(function(latLng) {
                                const lat = latLng.lat();
                                const lng = latLng.lng();
                                
                                polygon.pvAreaData.corners.push({
                                    latitude: lat,
                                    longitude: lng,
                                    ground_elevation: 0
                                });
                                
                                bounds.north = Math.max(bounds.north, lat);
                                bounds.south = Math.min(bounds.south, lat);
                                bounds.east = Math.max(bounds.east, lng);
                                bounds.west = Math.min(bounds.west, lng);
                            });
                            
                            polygon.pvAreaData.bounds = bounds;
                            polygon.pvAreaData.center = {
                                latitude: (bounds.north + bounds.south) / 2,
                                longitude: (bounds.east + bounds.west) / 2
                            };
                            polygon.pvAreaData.modifiedAt = new Date().toISOString();
                            
                            // Path reference is already updated through polygon.getPath()
                        }
                        
                        // Re-create all markers with new positions
                        createVertexMarkers();
                        createEdgeMoveMarkers();
                        
                        // Update only the azimuth input field without rebuilding the entire UI
                        if (polygon.pvAreaData) {
                            const azimuthInput = document.querySelector(`[data-pv-id="${polygon.pvAreaData.id}"] input[onchange*="azimuth"]`);
                            if (azimuthInput) {
                                azimuthInput.value = polygon.pvAreaData.azimuth;
                            }
                            
                            // Update perpendicular distance for roof-parallel areas
                            if (polygon.pvAreaData.type === 'roof-parallel') {
                                polygon.pvAreaData.perpendicularDistance = calculatePerpendicularDistance(polygon);
                                // Recalculate azimuth if auto-calculate is enabled
                                if (polygon.pvAreaData.autoCalculateAzimuth) {
                                    polygon.pvAreaData.azimuth = calculatePVAreaAzimuth(polygon);
                                }
                                // Recalculate auto-field if enabled
                                if (polygon.pvAreaData.autoCalculateField) {
                                    calculateAutoField(polygon.pvAreaData);
                                }
                                updateUI(); // Update to show new distance
                            }
                            
                            // Update dimension labels if shown
                            updatePVDimensions(polygon.pvAreaData);
                        }
                    }
                });
            }
            
            // For enhanced polygons, show vertex markers immediately
            if (polygon.isEnhanced) {
                editMode = true;
                createVertexMarkers();
                // Create appropriate markers based on editing mode
                if (polygon.editingMode === 'roof-parallel') {
                    createEdgeMoveMarkers();
                } else {
                    // For standard mode, create midpoint markers
                    updateMidpointMarkers();
                }
            }
            
            // Click on polygon to enter edit mode
            google.maps.event.addListener(polygon, 'click', function() {
                if (!editMode) {
                    editMode = true;
                    createVertexMarkers();
                    polygon.setOptions({ strokeWeight: 3, strokeOpacity: 1 });
                }
            });
            
            // Click on map to exit edit mode
            google.maps.event.addListener(map, 'click', function() {
                if (editMode && !polygon.isRoofArea) {
                    editMode = false;
                    markers.forEach(m => m.setMap(null));
                    midpointMarkers.forEach(m => m.setMap(null));
                    edgeMoveMarkers.forEach(m => m.setMap(null));
                    polygon.setOptions({ strokeWeight: 2, strokeOpacity: 1 });
                }
            });
            
            // Update markers when polygon is dragged
            google.maps.event.addListener(polygon, 'drag', function() {
                // Always update markers for roof areas or when in edit mode
                if (editMode || polygon.isRoofArea) {
                    const currentPath = polygon.getPath();
                    
                    // Update marker positions during drag
                    currentPath.forEach((vertex, index) => {
                        if (markers[index]) {
                            markers[index].setPosition(vertex);
                            
                            // Update double arrow position
                            if (markers[index].doubleArrowMarker) {
                                markers[index].doubleArrowMarker.setPosition(vertex);
                            }
                        }
                    });
                    
                    // Update edge marker positions and edge lines
                    if (polygon.isRoofArea && edgeMoveMarkers.length > 0) {
                        const midpoint12 = new google.maps.LatLng(
                            (currentPath.getAt(0).lat() + currentPath.getAt(1).lat()) / 2,
                            (currentPath.getAt(0).lng() + currentPath.getAt(1).lng()) / 2
                        );
                        const midpoint34 = new google.maps.LatLng(
                            (currentPath.getAt(2).lat() + currentPath.getAt(3).lat()) / 2,
                            (currentPath.getAt(2).lng() + currentPath.getAt(3).lng()) / 2
                        );
                        if (edgeMoveMarkers[0]) edgeMoveMarkers[0].setPosition(midpoint12);
                        if (edgeMoveMarkers[1]) edgeMoveMarkers[1].setPosition(midpoint34);
                        
                        // Update edge lines
                        if (edgeLines.length >= 2) {
                            edgeLines[0].setPath([currentPath.getAt(0), currentPath.getAt(1)]);
                            edgeLines[1].setPath([currentPath.getAt(2), currentPath.getAt(3)]);
                        }
                        
                        // Update rotation marker position
                        if (rotationMarker) {
                            const center = new google.maps.LatLng(
                                (currentPath.getAt(0).lat() + currentPath.getAt(1).lat() + currentPath.getAt(2).lat() + currentPath.getAt(3).lat()) / 4,
                                (currentPath.getAt(0).lng() + currentPath.getAt(1).lng() + currentPath.getAt(2).lng() + currentPath.getAt(3).lng()) / 4
                            );
                            rotationMarker.setPosition(center);
                        }
                    }
                }
                
                // Update dimension labels if shown
                if (polygon.pvAreaData) {
                    updatePVDimensions(polygon.pvAreaData);
                }
            });
            
            // Add dragstart to hide dimensions while dragging
            google.maps.event.addListener(polygon, 'dragstart', function() {
                // Hide dimension labels while dragging
                if (polygon.pvAreaData && polygon.pvAreaData.showDimensions && polygon.pvAreaData.dimensionOverlays) {
                    polygon.pvAreaData.dimensionOverlays.forEach(overlay => {
                        overlay.setMap(null);
                    });
                }
            });
            
            google.maps.event.addListener(polygon, 'dragend', function() {
                if (editMode || polygon.isEnhanced) {
                    // Recreate all markers to ensure proper state after drag
                    createVertexMarkers();
                    if (polygon.editingMode === 'roof-parallel') {
                        createEdgeMoveMarkers();
                    }
                }
                
                // Update reference height if auto-calculate is enabled
                if (polygon.pvAreaData && polygon.pvAreaData.autoCalculateReferenceHeight) {
                    calculateReferenceHeight(polygon.pvAreaData);
                }
                
                // Update dimension labels if shown (this will recreate them)
                if (polygon.pvAreaData && polygon.pvAreaData.showDimensions) {
                    updatePVDimensions(polygon.pvAreaData);
                }
            });
            
            // Listen for path changes
            google.maps.event.addListener(polygon.getPath(), 'set_at', function() {
                if (editMode) {
                    updateMidpointMarkers();
                }
                // Update perpendicular distance for roof-parallel areas
                if (polygon.pvAreaData && polygon.pvAreaData.type === 'roof-parallel') {
                    polygon.pvAreaData.perpendicularDistance = calculatePerpendicularDistance(polygon);
                    // Recalculate azimuth if auto-calculate is enabled
                    if (polygon.pvAreaData.autoCalculateAzimuth) {
                        polygon.pvAreaData.azimuth = calculatePVAreaAzimuth(polygon);
                    }
                    // Recalculate auto-field if enabled
                    if (polygon.pvAreaData.autoCalculateField) {
                        calculateAutoField(polygon.pvAreaData);
                    }
                    updateUI(); // Update the display
                }
                // Update dimension labels if shown
                if (polygon.pvAreaData) {
                    updatePVDimensions(polygon.pvAreaData);
                }
            });
            
            google.maps.event.addListener(polygon.getPath(), 'insert_at', function() {
                if (editMode) {
                    updateMidpointMarkers();
                }
                // Update perpendicular distance for roof-parallel areas
                if (polygon.pvAreaData && polygon.pvAreaData.type === 'roof-parallel') {
                    polygon.pvAreaData.perpendicularDistance = calculatePerpendicularDistance(polygon);
                    // Recalculate azimuth if auto-calculate is enabled
                    if (polygon.pvAreaData.autoCalculateAzimuth) {
                        polygon.pvAreaData.azimuth = calculatePVAreaAzimuth(polygon);
                    }
                    // Recalculate auto-field if enabled
                    if (polygon.pvAreaData.autoCalculateField) {
                        calculateAutoField(polygon.pvAreaData);
                    }
                }
                // Update corner heights dialog if it's open for this PV area
                if (polygon.pvAreaData) {
                    updateCornerHeightsDialogIfOpen(polygon.pvAreaData.id);
                    updateUI(); // Update the display
                }
                // Update dimension labels if shown
                if (polygon.pvAreaData) {
                    updatePVDimensions(polygon.pvAreaData);
                }
            });
        }
        
        // PV Array drawing functions
        function startDrawingExcluded() {
            drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
            drawingManager.setOptions({
                polygonOptions: {
                    fillColor: '#dc3545',
                    fillOpacity: 0.3,
                    strokeWeight: 2,
                    strokeColor: '#dc3545',
                    editable: true,
                    draggable: true
                }
            });
        }
        
        function startDrawingObstacle() {
            drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
            drawingManager.setOptions({
                polygonOptions: {
                    fillColor: '#666666',
                    fillOpacity: 0.6,
                    strokeWeight: 2,
                    strokeColor: '#333333',
                    editable: true,
                    draggable: true
                }
            });
        }
        
        // Address search (for manual button click)
        function searchAddress() {
            const input = document.getElementById('address-search').value.trim();
            if (!input) return;
            
            // Check if input is coordinates (lat, lng)
            const coordPattern = /^(-?\d+\.?\d*),\s*(-?\d+\.?\d*)$/;
            const match = input.match(coordPattern);
            
            if (match) {
                // Handle coordinates
                const lat = parseFloat(match[1]);
                const lng = parseFloat(match[2]);
                
                if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                    const location = new google.maps.LatLng(lat, lng);
                    map.setCenter(location);
                    map.setZoom(18);
                } else {
                    alert('Ungültige Koordinaten');
                }
            } else {
                // Handle address
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ 
                    address: input,
                    componentRestrictions: { country: ['de', 'at', 'ch'] }
                }, (results, status) => {
                    if (status === 'OK') {
                        map.setCenter(results[0].geometry.location);
                        map.setZoom(18);
                    } else {
                        alert('Adresse nicht gefunden');
                    }
                });
            }
        }
        
        // Enter key for search
        document.getElementById('address-search').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchAddress();
            }
        });
        
        // Initialize preview on load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize tooltips
            var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
            var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl)
            });
        });
        
        // Calculate rotation matrix for 3D rotation
        function rotationMatrix(axis, theta) {
            // Normalize axis
            const axisLength = Math.sqrt(axis[0]*axis[0] + axis[1]*axis[1] + axis[2]*axis[2]);
            axis = [axis[0]/axisLength, axis[1]/axisLength, axis[2]/axisLength];
            
            const a = Math.cos(theta / 2.0);
            const b = -axis[0] * Math.sin(theta / 2.0);
            const c = -axis[1] * Math.sin(theta / 2.0);
            const d = -axis[2] * Math.sin(theta / 2.0);
            
            const aa = a * a, bb = b * b, cc = c * c, dd = d * d;
            const bc = b * c, ad = a * d, ac = a * c, ab = a * b, bd = b * d, cd = c * d;
            
            return [
                [aa + bb - cc - dd, 2 * (bc + ad), 2 * (bd - ac)],
                [2 * (bc - ad), aa + cc - bb - dd, 2 * (cd + ab)],
                [2 * (bd + ac), 2 * (cd - ab), aa + dd - bb - cc]
            ];
        }
        
        // Matrix multiplication for 3x3 matrix and 3x1 vector
        function matrixVectorMultiply(matrix, vector) {
            return [
                matrix[0][0] * vector[0] + matrix[0][1] * vector[1] + matrix[0][2] * vector[2],
                matrix[1][0] * vector[0] + matrix[1][1] * vector[1] + matrix[1][2] * vector[2],
                matrix[2][0] * vector[0] + matrix[2][1] * vector[1] + matrix[2][2] * vector[2]
            ];
        }
        
        // Calculate angle between two vectors
        function vectorAngle(v1, v2, acute = true) {
            const dot = v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
            const norm1 = Math.sqrt(v1[0]*v1[0] + v1[1]*v1[1] + v1[2]*v1[2]);
            const norm2 = Math.sqrt(v2[0]*v2[0] + v2[1]*v2[1] + v2[2]*v2[2]);
            let angle = Math.acos(dot / (norm1 * norm2));
            
            if (!acute) {
                angle = 2 * Math.PI - angle;
            }
            return angle * 180 / Math.PI;
        }
        
        // Calculate effective azimuth and tilt considering cross tilt
        function calculateEffectiveValues(azimuth, tilt, crossTilt) {
            // Convert to radians
            const tilRad = tilt * Math.PI / 180;
            const aziRad = azimuth * Math.PI / 180;
            const rotRad = crossTilt * Math.PI / 180;
            
            // Rotation axis orientation (perpendicular to azimuth)
            const rotDir = azimuth - 90;
            const rotDirRad = rotDir * Math.PI / 180;
            
            // Rotation axis in 3D
            const rotAxisX = Math.sin(rotDirRad - Math.PI/2);
            const rotAxisY = Math.cos(rotDirRad - Math.PI/2);
            const rotationAxis = [rotAxisX, rotAxisY, 0];
            
            // Convert tilt/azimuth to normal vector
            // Spherical to Cartesian conversion
            const a = -(azimuth - 90) * Math.PI / 180;
            const x = Math.sin(tilRad) * Math.cos(a);
            const y = Math.sin(tilRad) * Math.sin(a);
            const z = Math.cos(tilRad);
            
            let normal = [x, y, z];
            
            // Apply rotation if cross tilt is not zero
            if (Math.abs(crossTilt) > 0.01) {
                const rotMatrix = rotationMatrix(rotationAxis, rotRad);
                normal = matrixVectorMultiply(rotMatrix, normal);
            }
            
            // Calculate new azimuth
            const meridian = [0, 1, 0];
            const normalXY = [normal[0], normal[1], 0];
            const normalXYLength = Math.sqrt(normalXY[0]*normalXY[0] + normalXY[1]*normalXY[1]);
            
            let newAzimuth = 180; // Default south
            if (normalXYLength > 0.001) {
                normalXY[0] /= normalXYLength;
                normalXY[1] /= normalXYLength;
                newAzimuth = vectorAngle(normalXY, meridian, azimuth <= 180);
            }
            
            // Calculate new tilt
            let newTilt = 0;
            if (normalXYLength > 0.001) {
                newTilt = Math.atan(normal[2] / normalXYLength);
                newTilt = 90 - newTilt * 180 / Math.PI;
            } else {
                // If normal points straight up or down
                newTilt = normal[2] > 0 ? 0 : 180;
            }
            
            return {
                azimuth: Math.round(newAzimuth * 10) / 10,
                tilt: Math.round(newTilt * 10) / 10
            };
        }
        
        // Calculate best fit plane for a set of 3D points
        function calculateBestFitPlane(points) {
            const n = points.length;
            if (n < 3) return null;
            
            // For exactly 3 points, calculate the normal directly
            if (n === 3) {
                // Vectors from point 0 to points 1 and 2
                const v1 = {
                    x: points[1].x - points[0].x,
                    y: points[1].y - points[0].y,
                    z: points[1].z - points[0].z
                };
                const v2 = {
                    x: points[2].x - points[0].x,
                    y: points[2].y - points[0].y,
                    z: points[2].z - points[0].z
                };
                
                // Cross product gives normal
                const normal = {
                    x: v1.y * v2.z - v1.z * v2.y,
                    y: v1.z * v2.x - v1.x * v2.z,
                    z: v1.x * v2.y - v1.y * v2.x
                };
                
                // Normalize
                const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                if (length > 0) {
                    normal.x /= length;
                    normal.y /= length;
                    normal.z /= length;
                }
                
                // Calculate d using point 0
                const d = -(normal.x * points[0].x + normal.y * points[0].y + normal.z * points[0].z);
                
                return {
                    normal: normal,
                    d: d,
                    centroid: points[0]
                };
            }
            
            // For 4 or more points, use least squares fitting
            // Calculate centroid
            let sumX = 0, sumY = 0, sumZ = 0;
            points.forEach(p => {
                sumX += p.x;
                sumY += p.y;
                sumZ += p.z;
            });
            const centroid = { x: sumX/n, y: sumY/n, z: sumZ/n };
            
            // Create matrix A for least squares
            // We'll solve for plane equation: ax + by + c = z
            let sumXX = 0, sumXY = 0, sumXZ = 0;
            let sumYY = 0, sumYZ = 0;
            let sumX2 = 0, sumY2 = 0, sumZ2 = 0;
            
            points.forEach(p => {
                const dx = p.x - centroid.x;
                const dy = p.y - centroid.y;
                
                sumXX += dx * dx;
                sumXY += dx * dy;
                sumXZ += dx * p.z;
                sumYY += dy * dy;
                sumYZ += dy * p.z;
                sumX2 += dx;
                sumY2 += dy;
                sumZ2 += p.z;
            });
            
            // Solve normal equations
            const det = sumXX * sumYY - sumXY * sumXY;
            let a, b;
            
            if (Math.abs(det) > 1e-10) {
                a = (sumXZ * sumYY - sumYZ * sumXY) / det;
                b = (sumYZ * sumXX - sumXZ * sumXY) / det;
            } else {
                // Points are colinear, use default
                a = 0;
                b = 0;
            }
            
            // Normal vector is (-a, -b, 1) normalized
            const normal = { x: -a, y: -b, z: 1 };
            const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
            normal.x /= length;
            normal.y /= length;
            normal.z /= length;
            
            // Calculate d for plane equation ax + by + cz + d = 0
            const d = -(normal.x * centroid.x + normal.y * centroid.y + normal.z * centroid.z);
            
            return {
                normal: normal,
                d: d,
                centroid: centroid
            };
        }
        
        // Update corner heights dialog if it's open
        function updateCornerHeightsDialogIfOpen(pvId) {
            const panel = document.getElementById('cornerHeightsPanel');
            if (!panel) return;
            
            // Check if panel is visible and showing data for this PV area
            if (panel.style.right === '0px' && panel.dataset.pvId === pvId) {
                console.log('Updating corner heights dialog for:', pvId);
                // Re-build the dialog content
                buildCornerHeightsContent(pvId);
            }
        }
        
        // Build corner heights content (extracted for reusability)
        function buildCornerHeightsContent(pvId) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (!pvArea || !pvArea.polygon) return;
            
            const panel = document.getElementById('cornerHeightsPanel');
            const content = document.getElementById('cornerHeightsContent');
            if (!content) return;
            
            // Store pvId for later use
            panel.dataset.pvId = pvId;
            
            // Get current polygon corners
            const path = pvArea.polygon.getPath();
            const corners = [];
            path.forEach((latLng, i) => {
                corners.push({
                    index: i,
                    lat: latLng.lat(),
                    lng: latLng.lng()
                });
            });
            
            // Update corner heights array to match current number of corners
            if (!pvArea.cornerHeights) {
                pvArea.cornerHeights = [];
            }
            
            // Resize corner heights array to match polygon corners
            while (pvArea.cornerHeights.length < corners.length) {
                pvArea.cornerHeights.push({
                    groundHeight: null,
                    heightAboveGround: 0,
                    autoCalculateGround: true
                });
            }
            while (pvArea.cornerHeights.length > corners.length) {
                pvArea.cornerHeights.pop();
            }
            
            // Initialize reference height if not exists
            if (pvArea.referenceGroundHeight === undefined) {
                pvArea.referenceGroundHeight = 0;
                pvArea.autoCalculateReference = true;
            }
            
            // Build interface
            let html = `
                <div class="mb-3">
                    <label class="form-label">
                        Referenzhöhe / Geländehöhe (m)
                        <i class="bi bi-info-circle text-muted ms-1" 
                           style="cursor: pointer; font-size: 0.75rem;" 
                           data-bs-toggle="tooltip" 
                           data-bs-placement="top"
                           data-bs-html="true"
                           title="Die Referenzhöhe ist die Basis für alle Höhenangaben.<br>Bei Auto-Calculate wird der Mittelwert der Geländehöhen aller Eckpunkte verwendet.">
                        </i>
                    </label>
                    <div class="input-group">
                        <input type="number" class="form-control" id="reference-ground-height"
                               value="${pvArea.referenceGroundHeight || 0}"
                               step="0.1"
                               ${pvArea.autoCalculateReference ? 'disabled' : ''}>
                        <div class="input-group-text">
                            <input class="form-check-input" type="checkbox" id="auto-calc-reference"
                                   ${pvArea.autoCalculateReference ? 'checked' : ''}
                                   title="Auto-calculate aus Eckpunkten">
                            <label class="form-check-label ms-2" for="auto-calc-reference">
                                Auto
                            </label>
                        </div>
                    </div>
                </div>
                
                <table class="table table-sm">
                    <thead>
                        <tr>
                            <th>Punkt</th>
                            <th>Latitude</th>
                            <th>Longitude</th>
                            <th>Höhe über Referenz (m)
                                <i class="bi bi-info-circle text-muted ms-1" 
                                   style="cursor: pointer; font-size: 0.75rem;" 
                                   data-bs-toggle="tooltip" 
                                   data-bs-placement="top"
                                   data-bs-html="true"
                                   title="Höhe des Eckpunkts über der Referenzhöhe/Geländehöhe.">
                                </i>
                            </th>
                            <th>Resultierende Gesamthöhe (m)
                                <i class="bi bi-info-circle text-muted ms-1" 
                                   style="cursor: pointer; font-size: 0.75rem;" 
                                   data-bs-toggle="tooltip" 
                                   data-bs-placement="top"
                                   data-bs-html="true"
                                   title="Die resultierende Gesamthöhe ist das Ergebnis der Best-Fit-Ebene, die als Dachfläche in der Simulation berücksichtigt wird.">
                                </i>
                            </th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            corners.forEach((corner, i) => {
                const cornerData = pvArea.cornerHeights[i];
                const pointName = pvArea.type === 'roof-parallel' ? 
                    (i === 0 ? 'P1 (Oberkante links)' :
                     i === 1 ? 'P2 (Oberkante rechts)' :
                     i === 2 ? 'P3 (Unterkante rechts)' : 'P4 (Unterkante links)') :
                    `P${i + 1}`;
                
                html += `
                    <tr>
                        <td>${pointName}</td>
                        <td>${corner.lat.toFixed(6)}</td>
                        <td>${corner.lng.toFixed(6)}</td>
                        <td>
                            <input type="number" class="form-control form-control-sm height-above-reference" 
                                   data-corner="${i}"
                                   value="${cornerData.heightAboveGround || 0}"
                                   step="0.1">
                        </td>
                        <td class="resulting-height" data-corner="${i}">-</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            content.innerHTML = html;
            
            // Initialize tooltips
            const tooltipTriggerList = content.querySelectorAll('[data-bs-toggle="tooltip"]');
            [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
            
            // Add event listeners
            const referenceInput = document.getElementById('reference-ground-height');
            const autoCalcCheckbox = document.getElementById('auto-calc-reference');
            
            autoCalcCheckbox.addEventListener('change', function() {
                referenceInput.disabled = this.checked;
                pvArea.autoCalculateReference = this.checked;
                if (this.checked) {
                    calculateReferenceHeightForDialog(pvId);
                }
                updateResultingHeights(pvId);
            });
            
            referenceInput.addEventListener('input', function() {
                pvArea.referenceGroundHeight = parseFloat(this.value) || 0;
                updateResultingHeights(pvId);
            });
            
            // Add listeners for height inputs
            content.querySelectorAll('.height-above-reference').forEach(input => {
                input.addEventListener('input', function() {
                    const cornerIndex = parseInt(this.dataset.corner);
                    pvArea.cornerHeights[cornerIndex].heightAboveGround = parseFloat(this.value) || 0;
                    updateResultingHeights(pvId);
                });
            });
            
            // Initial calculation
            if (pvArea.autoCalculateReference) {
                calculateReferenceHeightForDialog(pvId);
            } else {
                updateResultingHeights(pvId);
            }
        }
        
        // Open corner heights panel
        window.openCornerHeightsDialog = function(pvId) {
            console.log('Opening corner heights dialog for:', pvId);
            
            // Ensure DOM is ready
            if (!document.getElementById('cornerHeightsPanel')) {
                console.error('DOM not ready, trying again in 100ms');
                setTimeout(() => window.openCornerHeightsDialog(pvId), 100);
                return;
            }
            
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (!pvArea) {
                console.error('PV area not found:', pvId);
                return;
            }
            if (!pvArea.polygon) {
                console.error('PV area has no polygon:', pvId);
                return;
            }
            
            // Open side panel instead of modal
            const panel = document.getElementById('cornerHeightsPanel');
            if (!panel) {
                console.error('cornerHeightsPanel element not found!');
                alert('Fehler: Das Eckpunkt-Höhen Panel konnte nicht gefunden werden. Bitte laden Sie die Seite neu.');
                return;
            }
            
            // Build the content using the reusable function
            buildCornerHeightsContent(pvId);
            
            // Show panel with animation
            panel.style.right = '0';
            
            // Adjust map container to make room for panel
            const mapContainer = document.querySelector('.map-container');
            mapContainer.style.marginRight = '600px';
            mapContainer.style.transition = 'margin-right 0.3s ease-in-out';
            
            // Add ESC key handler
            const escHandler = function(e) {
                if (e.key === 'Escape') {
                    closeCornerHeightsPanel();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
            panel.escHandler = escHandler;
            
            // Calculate reference height if auto-calculate is enabled
            console.log('PV Area autoCalculateReference:', pvArea.autoCalculateReference);
            if (pvArea.autoCalculateReference) {
                console.log('Starting auto-calculation of reference height...');
                // Try to calculate reference height
                calculateReferenceHeightForDialog(pvId).then(() => {
                    console.log('Reference height calculated:', pvArea.referenceGroundHeight);
                    // After reference height is calculated, update resulting heights
                    updateResultingHeights(pvId);
                }).catch(error => {
                    console.error('Error calculating reference height:', error);
                    updateResultingHeights(pvId);
                });
            } else {
                // If not auto-calculating, still update resulting heights
                updateResultingHeights(pvId);
            }
        }
        
        // Calculate reference height as average of all corner elevations (for dialog)
        async function calculateReferenceHeightForDialog(pvId) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (!pvArea || !pvArea.polygon) {
                console.error('No PV area or polygon found');
                return;
            }
            
            const path = pvArea.polygon.getPath();
            const locations = [];
            
            path.forEach((latLng) => {
                locations.push({ lat: latLng.lat(), lng: latLng.lng() });
            });
            
            console.log('Requesting elevation for', locations.length, 'locations');
            
            const elevator = new google.maps.ElevationService();
            try {
                const response = await elevator.getElevationForLocations({
                    locations: locations
                });
                
                if (response.results && response.results.length > 0) {
                    let sumElevation = 0;
                    response.results.forEach((result, i) => {
                        sumElevation += result.elevation;
                        console.log(`Corner ${i} elevation: ${result.elevation}m`);
                    });
                    
                    const avgElevation = sumElevation / response.results.length;
                    pvArea.referenceGroundHeight = Math.round(avgElevation * 10) / 10;
                    
                    console.log(`Average elevation (reference height): ${pvArea.referenceGroundHeight}m`);
                    
                    // Update UI
                    const input = document.getElementById('reference-ground-height');
                    if (input) {
                        input.value = pvArea.referenceGroundHeight;
                    }
                    
                    updateResultingHeights(pvId);
                }
            } catch (error) {
                console.error('Error fetching elevation:', error);
            }
        }
        
        // Update resulting heights and best fit plane
        function updateResultingHeights(pvId) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (!pvArea) return;
            
            const points = [];
            const path = pvArea.polygon.getPath();
            const referenceHeight = pvArea.referenceGroundHeight || 0;
            
            // First, collect all points for plane calculation
            path.forEach((latLng, i) => {
                const cornerData = pvArea.cornerHeights[i];
                const heightAboveReference = cornerData.heightAboveGround || 0;
                const resultingHeight = referenceHeight + heightAboveReference;
                
                // Convert to local coordinate system for plane fitting
                if (i === 0) {
                    points.push({ x: 0, y: 0, z: resultingHeight });
                } else {
                    const dist = google.maps.geometry.spherical.computeDistanceBetween(
                        path.getAt(0), latLng
                    );
                    const heading = google.maps.geometry.spherical.computeHeading(
                        path.getAt(0), latLng
                    );
                    const x = dist * Math.sin(heading * Math.PI / 180);
                    const y = dist * Math.cos(heading * Math.PI / 180);
                    points.push({ x: x, y: y, z: resultingHeight });
                }
            });
            
            // Calculate best fit plane
            if (points.length >= 3) {
                const plane = calculateBestFitPlane(points);
                if (plane) {
                    // Update UI with best-fit plane heights
                    points.forEach((p, i) => {
                        const bestFitHeight = -(plane.normal.x * p.x + plane.normal.y * p.y + plane.d) / plane.normal.z;
                        const td = document.querySelector(`.resulting-height[data-corner="${i}"]`);
                        if (td) {
                            td.textContent = bestFitHeight.toFixed(1);
                        }
                    });
                }
            } else {
                // If less than 3 points, just show the sum
                path.forEach((latLng, i) => {
                    const cornerData = pvArea.cornerHeights[i];
                    const heightAboveReference = cornerData.heightAboveGround || 0;
                    const resultingHeight = referenceHeight + heightAboveReference;
                    
                    const td = document.querySelector(`.resulting-height[data-corner="${i}"]`);
                    if (td) {
                        td.textContent = resultingHeight.toFixed(1);
                    }
                });
            }
        }
        
        // Close corner heights panel
        window.closeCornerHeightsPanel = function() {
            const panel = document.getElementById('cornerHeightsPanel');
            const mapContainer = document.querySelector('.map-container');
            
            if (!panel) {
                console.error('Corner heights panel not found in closeCornerHeightsPanel');
                return;
            }
            
            // Hide panel
            panel.style.right = '-600px';
            
            // Reset map container
            if (mapContainer) {
                mapContainer.style.marginRight = '0';
            }
            
            // Remove ESC handler
            if (panel.escHandler) {
                document.removeEventListener('keydown', panel.escHandler);
                panel.escHandler = null;
            }
            
            // Get pvId but don't remove corner markers - they should stay visible
            const pvId = panel.dataset.pvId;
        }
        
        // Save corner heights
        window.saveCornerHeights = function() {
            const panel = document.getElementById('cornerHeightsPanel');
            if (!panel) {
                console.error('Corner heights panel not found in saveCornerHeights');
                return;
            }
            const pvId = panel.dataset.pvId;
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (!pvArea) return;
            
            // Update reference height
            const referenceInput = document.getElementById('reference-ground-height');
            const autoCalcCheckbox = document.getElementById('auto-calc-reference');
            
            pvArea.autoCalculateReference = autoCalcCheckbox.checked;
            if (!autoCalcCheckbox.checked && referenceInput.value) {
                pvArea.referenceGroundHeight = parseFloat(referenceInput.value) || 0;
            }
            
            // Update corner heights above reference
            document.querySelectorAll('.height-above-reference').forEach(input => {
                const cornerIndex = parseInt(input.dataset.corner);
                pvArea.cornerHeights[cornerIndex].heightAboveGround = parseFloat(input.value) || 0;
            });
            
            // Close panel
            closeCornerHeightsPanel();
            
            // Re-create corner markers after saving
            updateCornerMarkers(pvArea);
            
            showMessage('Eckpunkt-Höhen gespeichert', 'Erfolg');
        }
        
        // Update corner markers for a PV area
        function updateCornerMarkers(pvArea) {
            console.log('Updating corner markers for PV area:', pvArea.id, 'Type:', pvArea.type);
            
            // Skip for roof-parallel - they get numbers from enhancePolygonEditing
            if (pvArea.type === 'roof-parallel') {
                console.log('Skipping corner markers for roof-parallel type');
                return;
            }
            
            // Remove existing corner markers
            if (pvArea.cornerMarkers) {
                pvArea.cornerMarkers.forEach(marker => marker.setMap(null));
            }
            pvArea.cornerMarkers = [];
            
            // Make sure we have a valid polygon
            if (!pvArea.polygon) {
                console.error('No polygon found for PV area');
                return;
            }
            
            // Add new corner markers - just the numbers, no symbols
            const path = pvArea.polygon.getPath();
            console.log('Number of corners:', path.getLength());
            
            // Use a slight delay to ensure Google Maps has finished rendering
            setTimeout(() => {
                path.forEach((latLng, i) => {
                    // Create a custom overlay for the number instead of a marker
                    const overlay = new google.maps.OverlayView();
                    
                    overlay.onAdd = function() {
                        const div = document.createElement('div');
                        div.style.position = 'absolute';
                        div.style.cursor = 'default';
                        div.style.userSelect = 'none';
                        div.style.fontSize = '14px';
                        div.style.fontWeight = 'bold';
                        div.style.color = '#FFFFFF';
                        div.style.textShadow = '1px 1px 1px rgba(0,0,0,0.8), -1px -1px 1px rgba(0,0,0,0.8)';
                        div.style.zIndex = '5000';
                        div.textContent = (i + 1).toString();
                        
                        const panes = this.getPanes();
                        panes.floatPane.appendChild(div);
                        this.div = div;
                    };
                    
                    overlay.draw = function() {
                        const projection = this.getProjection();
                        const position = projection.fromLatLngToDivPixel(latLng);
                        
                        if (this.div) {
                            // Gleicher Versatz wie bei dachparallel Labels
                            this.div.style.left = position.x + 'px';
                            this.div.style.top = (position.y - 16) + 'px';
                        }
                    };
                    
                    overlay.onRemove = function() {
                        if (this.div) {
                            this.div.parentNode.removeChild(this.div);
                            this.div = null;
                        }
                    };
                    
                    overlay.setMap(map);
                    pvArea.cornerMarkers.push(overlay);
                    console.log(`Added overlay ${i + 1} at position:`, latLng.lat(), latLng.lng());
                });
            }, 100);
        }
        
        // Remove corner markers for a PV area
        function removeCornerMarkers(pvArea) {
            // Skip for roof-parallel - they have their own system
            if (pvArea.type === 'roof-parallel') {
                return;
            }
            
            if (pvArea.cornerMarkers) {
                pvArea.cornerMarkers.forEach(overlay => {
                    overlay.setMap(null);
                });
                pvArea.cornerMarkers = [];
            }
        }
        
        // Create PV label for a PV area
        function createPVLabel(pvArea) {
            // Get the PV number
            const pvIndex = pvAreas.indexOf(pvArea) + 1;
            const labelText = `PV${pvIndex}`;
            
            
            // Simple marker at first corner
            if (pvArea.type === 'facade' && pvArea.facadeLine && pvArea.facadeLine.length > 0) {
                // For facades, place at first point
                const firstPoint = pvArea.facadeLine[0];
                pvArea.labelMarker = new google.maps.Marker({
                    position: firstPoint,
                    map: map,
                    label: {
                        text: labelText,
                        color: '#000',
                        fontSize: '12px',
                        fontWeight: 'bold'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 3,
                        fillColor: '#fff',
                        fillOpacity: 0.9,
                        strokeColor: '#333',
                        strokeWeight: 1,
                        anchor: new google.maps.Point(-15, -15)  // Offset label outside
                    },
                    clickable: false,
                    zIndex: 1000
                });
            } else if (pvArea.polygon) {
                // For polygons, place at first corner (P1)
                const path = pvArea.polygon.getPath();
                if (path.getLength() > 0) {
                    const firstCorner = path.getAt(0);
                    
                    // Calculate offset direction based on the angle to the second point
                    let offsetX = -20;
                    let offsetY = -20;
                    
                    if (path.getLength() > 1) {
                        const secondCorner = path.getAt(1);
                        const angle = google.maps.geometry.spherical.computeHeading(firstCorner, secondCorner);
                        
                        // Position label opposite to the polygon direction
                        if (angle > -45 && angle <= 45) {
                            // East - place label to the west
                            offsetX = -25;
                            offsetY = -10;
                        } else if (angle > 45 && angle <= 135) {
                            // South - place label to the north
                            offsetX = -10;
                            offsetY = -25;
                        } else if (angle > 135 || angle <= -135) {
                            // West - place label to the east
                            offsetX = 15;
                            offsetY = -10;
                        } else {
                            // North - place label to the south
                            offsetX = -10;
                            offsetY = 15;
                        }
                    }
                    
                    pvArea.labelMarker = new google.maps.Marker({
                        position: firstCorner,
                        map: map,
                        label: {
                            text: labelText,
                            color: '#000',
                            fontSize: '12px',
                            fontWeight: 'bold'
                        },
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 3,
                            fillColor: '#fff',
                            fillOpacity: 0.9,
                            strokeColor: '#333',
                            strokeWeight: 1,
                            anchor: new google.maps.Point(offsetX, offsetY)
                        },
                        clickable: false,
                        zIndex: 1000
                    });
                }
            }
        }
        
        // Update PV labels when order changes
        function updatePVLabels() {
            pvAreas.forEach((pvArea, index) => {
                if (pvArea.labelMarker) {
                    pvArea.labelMarker.setLabel({
                        text: `PV${index + 1}`,
                        color: '#000',
                        fontSize: '12px',
                        fontWeight: 'bold'
                    });
                }
            });
        }
        
        // Update cross tilt direction display based on azimuth
        function updateCrossTiltDirection(pvId) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (!pvArea) return;
            
            const azimuth = pvArea.azimuth || 0;
            const directionSpan = document.getElementById(`cross-tilt-direction-${pvId}`);
            if (!directionSpan) return;
            
            // Calculate the directions for positive and negative cross tilt
            // Positive cross tilt = rotation to the right (clockwise)
            // Negative cross tilt = rotation to the left (counter-clockwise)
            const rightDirection = (azimuth + 90) % 360;
            const leftDirection = (azimuth + 270) % 360;
            
            // Add compass directions for better clarity
            const getCompassDirection = (degrees) => {
                const normalized = degrees % 360;
                if (normalized === 0 || normalized === 360) return 'N';
                if (normalized === 90) return 'O';
                if (normalized === 180) return 'S';
                if (normalized === 270) return 'W';
                return normalized + '°';
            };
            
            const rightDir = getCompassDirection(rightDirection);
            const leftDir = getCompassDirection(leftDirection);
            
            directionSpan.innerHTML = `<small>(+ nach ${rightDirection.toFixed(1)}° / - nach ${leftDirection.toFixed(1)}°)</small>`;
            
            // Update effective values if cross tilt is not zero
            const crossTilt = pvArea.crossTilt || 0;
            const effectiveContainer = document.getElementById(`effective-values-${pvId}`);
            
            if (effectiveContainer && Math.abs(crossTilt) > 0.01) {
                const tilt = pvArea.tilt || 0;
                const effective = calculateEffectiveValues(azimuth, tilt, crossTilt);
                
                effectiveContainer.style.display = 'block';
                const effectiveAzimutSpan = document.getElementById(`effective-azimuth-${pvId}`);
                const effectiveTiltSpan = document.getElementById(`effective-tilt-${pvId}`);
                
                if (effectiveAzimutSpan) effectiveAzimutSpan.textContent = effective.azimuth + '°';
                if (effectiveTiltSpan) effectiveTiltSpan.textContent = effective.tilt + '°';
            } else if (effectiveContainer) {
                effectiveContainer.style.display = 'none';
            }
        }
        
        // Function to get serializable project data
        function getProjectData() {
            const projectData = {
                pvAreas: pvAreas.map(pv => {
                    // Create a copy without the polygon reference
                    const pvCopy = { ...pv };
                    delete pvCopy.polygon;
                    return pvCopy;
                }),
                observationPoints: observationPoints.map(op => {
                    // Create a copy without the marker reference
                    const opCopy = { ...op };
                    delete opCopy.marker;
                    return opCopy;
                }),
                projectMetadata: {
                    createdAt: window.projectCreatedAt || new Date().toISOString(),
                    modifiedAt: new Date().toISOString(),
                    version: '1.0'
                }
            };
            
            return projectData;
        }
        
        // Function to save project
        function saveProject() {
            const projectData = getProjectData();
            const dataStr = JSON.stringify(projectData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `glare_project_${new Date().toISOString().slice(0, 10)}.json`;
            link.click();
            
            console.log('Project saved:', projectData);
        }
        
        // Function to load project (placeholder for future implementation)
        function loadProject(projectData) {
            console.log('Loading project:', projectData);
            // TODO: Implement project loading
            // - Clear existing data
            // - Recreate polygons, markers, etc. from saved data
            // - Update UI
        }
        
        // Toggle PV area details
        function togglePVDetails(pvId) {
            const details = document.getElementById(`details-${pvId}`);
            const chevron = document.getElementById(`chevron-${pvId}`);
            
            if (details.classList.contains('d-none')) {
                details.classList.remove('d-none');
                chevron.classList.remove('fa-chevron-right');
                chevron.classList.add('fa-chevron-down');
            } else {
                details.classList.add('d-none');
                chevron.classList.remove('fa-chevron-down');
                chevron.classList.add('fa-chevron-right');
            }
        }
        
        // Drag & drop handlers
        let draggedItem = null;
        let draggedPvId = null;
        
        function handleDragStart(event, pvId) {
            draggedItem = event.target.closest('.pv-area-item');
            draggedPvId = pvId;
            if (draggedItem) {
                draggedItem.classList.add('dragging');
            }
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/html', event.target.innerHTML);
        }
        
        function handleDragOver(event) {
            if (event.preventDefault) {
                event.preventDefault();
            }
            event.dataTransfer.dropEffect = 'move';
            
            // Update visual feedback during drag over
            const item = event.target.closest('.pv-area-item');
            if (item && item !== draggedItem) {
                // Remove any existing drag-over classes
                item.classList.remove('drag-over-top', 'drag-over-bottom');
                
                // Determine position
                const rect = item.getBoundingClientRect();
                const mouseY = event.clientY;
                const elementMiddle = rect.top + rect.height / 2;
                
                if (mouseY < elementMiddle) {
                    item.classList.add('drag-over-top');
                } else {
                    item.classList.add('drag-over-bottom');
                }
            }
            
            return false;
        }
        
        function handleDragEnter(event) {
            const item = event.target.closest('.pv-area-item');
            if (item && item !== draggedItem) {
                // Remove any existing drag-over classes
                item.classList.remove('drag-over-top', 'drag-over-bottom');
                
                // Determine position
                const rect = item.getBoundingClientRect();
                const mouseY = event.clientY;
                const elementMiddle = rect.top + rect.height / 2;
                
                if (mouseY < elementMiddle) {
                    item.classList.add('drag-over-top');
                } else {
                    item.classList.add('drag-over-bottom');
                }
            }
        }
        
        function handleDragLeave(event) {
            const item = event.target.closest('.pv-area-item');
            if (item) {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            }
        }
        
        function handleDrop(event, targetPvId) {
            if (event.stopPropagation) {
                event.stopPropagation();
            }
            event.preventDefault();
            
            if (draggedPvId && targetPvId && draggedPvId !== targetPvId) {
                // Find indices
                const draggedIndex = pvAreas.findIndex(pv => pv.id === draggedPvId);
                const targetIndex = pvAreas.findIndex(pv => pv.id === targetPvId);
                
                if (draggedIndex !== -1 && targetIndex !== -1) {
                    // Remove dragged item
                    const [draggedPv] = pvAreas.splice(draggedIndex, 1);
                    
                    // Calculate new index after removal
                    let newIndex = targetIndex;
                    if (draggedIndex < targetIndex) {
                        newIndex = targetIndex - 1;
                    }
                    
                    // Get mouse position relative to target element
                    const targetElement = event.target.closest('.pv-area-item');
                    if (targetElement) {
                        const rect = targetElement.getBoundingClientRect();
                        const mouseY = event.clientY;
                        const elementMiddle = rect.top + rect.height / 2;
                        
                        // If mouse is below middle, insert after target
                        if (mouseY > elementMiddle) {
                            newIndex = newIndex + 1;
                        }
                    }
                    
                    // Insert at new position
                    pvAreas.splice(newIndex, 0, draggedPv);
                    
                    // Update UI to reflect new order
                    updateUI();
                    
                    // Update PV labels to reflect new numbering
                    updatePVLabels();
                }
            }
            
            // Clean up drop indicator
            const item = event.target.closest('.pv-area-item');
            if (item) {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            }
            
            return false;
        }
        
        function handleDragEnd(event) {
            // Clean up
            document.querySelectorAll('.pv-area-item').forEach(item => {
                item.classList.remove('dragging');
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            });
            draggedItem = null;
            draggedPvId = null;
        }
        
        // Swap top and bottom of PV area
        function swapTopBottom(pvId) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (!pvArea || pvArea.type !== 'roof-parallel') return;
            
            // Swap heights
            const tempHeight = pvArea.heightTop;
            pvArea.heightTop = pvArea.heightBottom;
            pvArea.heightBottom = tempHeight;
            
            // Get current polygon
            const oldPolygon = pvArea.polygon;
            const path = oldPolygon.getPath();
            const points = [];
            for (let i = 0; i < path.getLength(); i++) {
                points.push(path.getAt(i));
            }
            
            // Swap points: P1<->P3, P2<->P4 (swap top and bottom edges)
            if (points.length === 4) {
                const newPath = [points[2], points[3], points[0], points[1]];
                
                // Update stored corners
                pvArea.corners = newPath.map(p => ({
                    latitude: p.lat(),
                    longitude: p.lng(),
                    ground_elevation: 0
                }));
                
                // Update parallelogram points if they exist
                if (pvArea.parallelogramPoints) {
                    pvArea.parallelogramPoints = {
                        p1: { lat: newPath[0].lat(), lng: newPath[0].lng() },
                        p2: { lat: newPath[1].lat(), lng: newPath[1].lng() },
                        p3: { lat: newPath[2].lat(), lng: newPath[2].lng() },
                        p4: { lat: newPath[3].lat(), lng: newPath[3].lng() }
                    };
                }
                
                // Remove all old visual elements
                if (oldPolygon.associatedElements) {
                    const elements = oldPolygon.associatedElements;
                    
                    if (elements.edgeLines) {
                        elements.edgeLines.forEach(line => line.setMap(null));
                    }
                    if (elements.markers) {
                        elements.markers.forEach(m => {
                            if (m.doubleArrowMarker) {
                                m.doubleArrowMarker.setMap(null);
                            }
                            m.setMap(null);
                        });
                    }
                    if (elements.midpointMarkers) {
                        elements.midpointMarkers.forEach(m => m.setMap(null));
                    }
                    if (elements.edgeMoveMarkers) {
                        elements.edgeMoveMarkers.forEach(m => m.setMap(null));
                    }
                    if (elements.rotationMarker) {
                        elements.rotationMarker.setMap(null);
                    }
                    if (elements.azimuthArrow) {
                        elements.azimuthArrow.setMap(null);
                    }
                }
                
                // Remove old polygon
                oldPolygon.setMap(null);
                
                // Create new polygon with swapped points
                const newPolygon = new google.maps.Polygon({
                    paths: newPath,
                    strokeColor: '#4274a5',
                    strokeOpacity: 0.8,
                    strokeWeight: 2,
                    fillColor: '#4274a5',
                    fillOpacity: 0.35,
                    map: map,
                    draggable: true,
                    editable: false  // Important: false to prevent standard editing features
                });
                
                // Copy properties
                newPolygon.pvAreaData = pvArea;
                newPolygon.isRoofArea = true;
                
                // Update reference
                pvArea.polygon = newPolygon;
                
                // Make it editable again
                enhancePolygonEditing(newPolygon, true);
                
                // Recalculate values
                pvArea.perpendicularDistance = calculatePerpendicularDistance(newPolygon);
                if (pvArea.autoCalculateAzimuth !== false) {
                    pvArea.azimuth = calculatePVAreaAzimuth(newPolygon);
                }
                
                // Show confirmation
                showMessage('Ober- und Unterkante wurden getauscht.', 'Erfolgreich');
                
                // Update UI
                updateUI();
            }
        }
        
        // Toggle PV area lock
        function togglePVLock(pvId) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (!pvArea || !pvArea.polygon) return;
            
            // Toggle locked state
            pvArea.locked = !pvArea.locked;
            
            if (pvArea.locked) {
                // Lock the PV area
                pvArea.polygon.setDraggable(false);
                pvArea.polygon.setEditable(false);  // Ensure polygon can't be edited
                
                // Hide all editing elements
                if (pvArea.polygon.associatedElements) {
                    const elements = pvArea.polygon.associatedElements;
                    
                    // Hide markers
                    if (elements.markers) {
                        elements.markers.forEach(m => {
                            m.setVisible(false);
                            if (m.doubleArrowMarker) {
                                m.doubleArrowMarker.setVisible(false);
                            }
                        });
                    }
                    
                    // Hide midpoint markers
                    if (elements.midpointMarkers) {
                        elements.midpointMarkers.forEach(m => m.setVisible(false));
                    }
                    
                    // Hide edge move markers
                    if (elements.edgeMoveMarkers) {
                        elements.edgeMoveMarkers.forEach(m => m.setVisible(false));
                    }
                    
                    // Hide rotation marker
                    if (elements.rotationMarker) {
                        elements.rotationMarker.setVisible(false);
                    }
                    
                    // Hide azimuth arrow
                    if (elements.azimuthArrow) {
                        elements.azimuthArrow.setVisible(false);
                    }
                }
                
                // Hide corner number overlays
                if (pvArea.cornerMarkers) {
                    pvArea.cornerMarkers.forEach(overlay => {
                        overlay.setMap(null);
                    });
                }
                
                // Create lock icon in center
                const bounds = new google.maps.LatLngBounds();
                const path = pvArea.polygon.getPath();
                for (let i = 0; i < path.getLength(); i++) {
                    bounds.extend(path.getAt(i));
                }
                const center = bounds.getCenter();
                
                const lockMarker = new google.maps.Marker({
                    position: center,
                    map: map,
                    icon: {
                        path: 'M 5 8 V 7 A 5 5 0 0 1 15 7 V 8 M 7 8 L 7 8 A 3 3 0 0 0 7 14 L 13 14 A 3 3 0 0 0 13 8 L 7 8 M 10 10 V 12',
                        scale: 1.5,
                        fillColor: '#FFC107',
                        fillOpacity: 1,
                        strokeColor: '#F57C00',
                        strokeWeight: 2,
                        anchor: new google.maps.Point(10, 11)
                    },
                    clickable: false,
                    zIndex: 1000
                });
                
                // Store lock marker reference
                if (pvArea.polygon.associatedElements) {
                    pvArea.polygon.associatedElements.lockMarker = lockMarker;
                }
                // Also store it directly on pvArea for types without associatedElements
                pvArea.lockMarker = lockMarker;
            } else {
                // Unlock the PV area
                pvArea.polygon.setDraggable(true);
                
                // Show all editing elements
                if (pvArea.polygon.associatedElements) {
                    const elements = pvArea.polygon.associatedElements;
                    
                    // Show markers
                    if (elements.markers) {
                        elements.markers.forEach(m => {
                            m.setVisible(true);
                            if (m.doubleArrowMarker) {
                                m.doubleArrowMarker.setVisible(true);
                            }
                        });
                    }
                    
                    // Show midpoint markers
                    if (elements.midpointMarkers) {
                        elements.midpointMarkers.forEach(m => m.setVisible(true));
                    }
                    
                    // Show edge move markers
                    if (elements.edgeMoveMarkers) {
                        elements.edgeMoveMarkers.forEach(m => m.setVisible(true));
                    }
                    
                    // Show rotation marker
                    if (elements.rotationMarker) {
                        elements.rotationMarker.setVisible(true);
                    }
                    
                    // Show azimuth arrow
                    if (elements.azimuthArrow) {
                        elements.azimuthArrow.setVisible(true);
                    }
                    
                    // Remove lock marker
                    if (elements.lockMarker) {
                        elements.lockMarker.setMap(null);
                        delete elements.lockMarker;
                    }
                }
                
                // Also remove lock marker from pvArea
                if (pvArea.lockMarker) {
                    pvArea.lockMarker.setMap(null);
                    delete pvArea.lockMarker;
                }
                
                // Show corner number overlays again
                if (pvArea.cornerMarkers) {
                    pvArea.cornerMarkers.forEach(overlay => {
                        overlay.setMap(map);
                    });
                } else {
                    // Re-create corner markers if they don't exist
                    updateCornerMarkers(pvArea);
                }
            }
            
            // Update UI
            updateUI();
        }
        
        // Delete PV area
        function deletePVArea(pvId) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (!pvArea) return;
            
            // Show custom confirmation modal
            const modal = document.getElementById('deleteConfirmationModal');
            const modalBody = document.getElementById('deleteConfirmationBody');
            
            // Get the index for display
            const pvIndex = pvAreas.indexOf(pvArea) + 1;
            const displayName = `PV${pvIndex}${pvArea.name ? `: ${pvArea.name}` : ''}`;
            
            modalBody.innerHTML = `Möchten Sie die PV-Fläche "<strong>${displayName}</strong>" wirklich löschen?`;
            
            // Store pvId for confirmation
            window.pvAreaToDelete = pvId;
            
            // Show modal
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
        }
        
        // Confirm deletion
        function confirmDeletePVArea() {
            const pvId = window.pvAreaToDelete;
            if (pvId) {
                const pvArea = pvAreas.find(pv => pv.id === pvId);
                if (pvArea && pvArea.polygon) {
                    // Remove corner markers
                    removeCornerMarkers(pvArea);
                    
                    // Remove PV label
                    if (pvArea.labelMarker) {
                        pvArea.labelMarker.setMap(null);
                    }
                    
                    // Remove lock marker from pvArea (for types without associatedElements)
                    if (pvArea.lockMarker) {
                        pvArea.lockMarker.setMap(null);
                    }
                    
                    // Remove facade visualization if it exists
                    if (pvArea.type === 'facade' && pvArea.facadeVisualizationId && window.facadeVisualizations) {
                        const visualization = window.facadeVisualizations[pvArea.facadeVisualizationId];
                        if (visualization) {
                            if (visualization.line) visualization.line.setMap(null);
                            if (visualization.reflectiveArea) visualization.reflectiveArea.setMap(null);
                            delete window.facadeVisualizations[pvArea.facadeVisualizationId];
                        }
                    }
                    
                    // Clean up all associated elements
                    if (pvArea.polygon.associatedElements) {
                        const elements = pvArea.polygon.associatedElements;
                        
                        // Remove lock marker if exists
                        if (elements.lockMarker) {
                            elements.lockMarker.setMap(null);
                        }
                        
                        // Remove vertex markers and their double arrows
                        if (elements.markers) {
                            elements.markers.forEach(m => {
                                if (m.doubleArrowMarker) {
                                    m.doubleArrowMarker.setMap(null);
                                }
                                m.setMap(null);
                            });
                        }
                        
                        // Remove midpoint markers
                        if (elements.midpointMarkers) {
                            elements.midpointMarkers.forEach(m => m.setMap(null));
                        }
                        
                        // Remove edge move markers
                        if (elements.edgeMoveMarkers) {
                            elements.edgeMoveMarkers.forEach(m => m.setMap(null));
                        }
                        
                        // Remove edge lines (turquoise and orange)
                        if (elements.edgeLines) {
                            elements.edgeLines.forEach(l => l.setMap(null));
                        }
                        
                        // Remove rotation marker
                        if (elements.rotationMarker) {
                            elements.rotationMarker.setMap(null);
                        }
                        
                        // Remove azimuth arrow and label
                        if (elements.azimuthArrow) {
                            elements.azimuthArrow.setMap(null);
                        }
                        if (elements.azimuthLabel) {
                            elements.azimuthLabel.setMap(null);
                        }
                        
                        // Remove lock marker if exists
                        if (elements.lockMarker) {
                            elements.lockMarker.setMap(null);
                        }
                    }
                    
                    // Remove dimensions if shown
                    if (pvArea.showDimensions) {
                        hidePVDimensions(pvArea);
                    }
                    
                    // Remove the polygon itself
                    pvArea.polygon.setMap(null);
                }
                pvAreas = pvAreas.filter(pv => pv.id !== pvId);
                updateUI();
            }
        }
        
        // Update PV parameter
        function updatePVParameter(pvId, parameter, value) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (pvArea) {
                // Parse as float for numeric parameters, keep as string for name
                if (parameter === 'name') {
                    // Validate name: no empty names and no duplicates
                    const trimmedValue = value.trim();
                    if (!trimmedValue) {
                        showMessage('Die Bezeichnung darf nicht leer sein.', 'Ungültige Eingabe');
                        updateUI(); // Refresh to show old value
                        return;
                    }
                    // Check for duplicates
                    const duplicate = pvAreas.find(pv => pv.id !== pvId && pv.name === trimmedValue);
                    if (duplicate) {
                        showMessage('Diese Bezeichnung wird bereits verwendet.', 'Ungültige Eingabe');
                        updateUI(); // Refresh to show old value
                        return;
                    }
                    pvArea[parameter] = trimmedValue;
                } else {
                    // Replace comma with dot for decimal separator
                    const normalizedValue = value.replace(',', '.');
                    pvArea[parameter] = parseFloat(normalizedValue);
                    
                    // Special handling for tilt: clamp to 0-89
                    if (parameter === 'tilt') {
                        pvArea.tilt = Math.max(0, Math.min(89, pvArea.tilt));
                    }
                    
                    // Update cross tilt direction display when azimuth changes
                    if (parameter === 'azimuth') {
                        updateCrossTiltDirection(pvId);
                    }
                    
                    // Update effective values when azimuth, tilt or crossTilt changes
                    if (parameter === 'azimuth' || parameter === 'tilt' || parameter === 'crossTilt') {
                        updateCrossTiltDirection(pvId);
                    }
                    
                    // Validate height values
                    if (parameter === 'heightTop' || parameter === 'heightBottom') {
                        // Check if both heights are set
                        if (pvArea.heightTop !== null && pvArea.heightBottom !== null && 
                            pvArea.heightTop !== undefined && pvArea.heightBottom !== undefined &&
                            !isNaN(pvArea.heightTop) && !isNaN(pvArea.heightBottom)) {
                            
                            // Check if top is lower than bottom
                            if (pvArea.heightTop < pvArea.heightBottom) {
                                showMessage('Die Höhe der Oberkante muss größer oder gleich der Höhe der Unterkante sein.', 'Ungültiger Wert');
                            }
                        }
                    }
                }
                pvArea.modifiedAt = new Date().toISOString();
                console.log(`Updated ${parameter} to ${value} for PV area ${pvId}`);
                
                // Trigger auto-calculation if needed
                if (pvArea.type === 'roof-parallel' && pvArea.autoCalculateField && 
                    (parameter === 'tilt' || parameter === 'heightTop' || parameter === 'heightBottom')) {
                    calculateAutoField(pvArea);
                    updateUI(); // Update UI to show calculated value
                }
                
                // Send update to backend
                const serializableData = { ...pvArea };
                delete serializableData.polygon;
                
                fetch('/api/pv_area', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(serializableData)
                });
                
                // Update UI if name was changed
                if (parameter === 'name') {
                    updateUI();
                }
            }
        }
        
        // Focus on PV area on map
        function focusPVArea(pvId) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (pvArea && pvArea.center) {
                // Pan to center
                map.panTo(new google.maps.LatLng(pvArea.center.latitude, pvArea.center.longitude));
                
                // Flash the polygon
                if (pvArea.polygon) {
                    pvArea.polygon.setOptions({
                        fillOpacity: 0.7,
                        strokeWeight: 4
                    });
                    
                    setTimeout(() => {
                        pvArea.polygon.setOptions({
                            fillOpacity: 0.4,
                            strokeWeight: 2
                        });
                    }, 500);
                }
            }
        }
        
        // Duplicate PV area
        function duplicatePVArea(pvId) {
            console.log('Duplicate PV area:', pvId);
            // TODO: Implement duplication
            alert('Duplizieren-Funktion wird noch implementiert');
        }
        
        // Edit PV area shape
        function editPVAreaShape(pvId) {
            console.log('Edit PV area shape:', pvId);
            // TODO: Implement shape editing
            alert('Form-Bearbeitung wird noch implementiert');
        }
        
        // Export single PV area
        function exportPVArea(pvId) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (pvArea) {
                const exportData = { ...pvArea };
                delete exportData.polygon;
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `pv_area_${pvArea.name.replace(/\s+/g, '_')}.json`;
                link.click();
            }
        }
        
        // Toggle PV dimensions display
        function togglePVDimensions(pvId) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (!pvArea || !pvArea.polygon) return;
            
            // Toggle dimensions state
            if (!pvArea.showDimensions) {
                pvArea.showDimensions = true;
                showPVDimensions(pvArea);
            } else {
                pvArea.showDimensions = false;
                hidePVDimensions(pvArea);
            }
            
            // Update UI to reflect button state change
            updateUI();
        }
        
        // Show dimensions for a PV area
        function showPVDimensions(pvArea) {
            if (!pvArea.dimensionOverlays) {
                pvArea.dimensionOverlays = [];
            }
            
            const path = pvArea.polygon.getPath();
            const points = [];
            
            // Get all points
            for (let i = 0; i < path.getLength(); i++) {
                points.push(path.getAt(i));
            }
            
            // Calculate distances for each edge
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                
                // Calculate distance
                const distance = google.maps.geometry.spherical.computeDistanceBetween(p1, p2);
                
                // Calculate midpoint
                const midLat = (p1.lat() + p2.lat()) / 2;
                const midLng = (p1.lng() + p2.lng()) / 2;
                const midPoint = new google.maps.LatLng(midLat, midLng);
                
                // Calculate offset direction (perpendicular to edge, pointing outward)
                const bearing = google.maps.geometry.spherical.computeHeading(p1, p2);
                const offsetBearing = bearing + 90; // Perpendicular
                
                // Check if offset should point outward
                const center = pvArea.center;
                const centerLatLng = new google.maps.LatLng(center.latitude, center.longitude);
                const bearingToCenter = google.maps.geometry.spherical.computeHeading(midPoint, centerLatLng);
                
                let finalBearing = offsetBearing;
                if (Math.abs(bearingToCenter - offsetBearing) < 90) {
                    finalBearing = offsetBearing + 180; // Point away from center
                }
                
                // Calculate offset position (closer to edge)
                const offsetDistance = 8; // meters (reduced from 20)
                const offsetPoint = google.maps.geometry.spherical.computeOffset(midPoint, offsetDistance, finalBearing);
                
                // Create text label with black outline (no line)
                const label = new google.maps.Marker({
                    position: offsetPoint,
                    map: map,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 0
                    },
                    label: {
                        text: `${distance.toFixed(1)} m`,
                        color: '#FFFFFF',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        strokeColor: '#000000',
                        strokeWeight: 3
                    },
                    zIndex: 1002
                });
                
                // Store overlays
                pvArea.dimensionOverlays.push(label);
            }
        }
        
        // Hide dimensions for a PV area
        function hidePVDimensions(pvArea) {
            if (pvArea.dimensionOverlays) {
                pvArea.dimensionOverlays.forEach(overlay => {
                    overlay.setMap(null);
                });
                pvArea.dimensionOverlays = [];
            }
        }
        
        // Update dimensions when polygon changes
        function updatePVDimensions(pvArea) {
            if (pvArea.showDimensions) {
                // Remove old dimensions
                hidePVDimensions(pvArea);
                // Recreate dimensions with new positions
                showPVDimensions(pvArea);
            }
        }
        
        // Toggle auto-calculate azimuth
        function toggleAutoCalculate(pvId, checked) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (pvArea) {
                pvArea.autoCalculateAzimuth = checked;
                
                const azimuthInput = document.getElementById(`azimuth-${pvId}`);
                if (azimuthInput) {
                    // Enable/disable the input field
                    azimuthInput.disabled = checked;
                    
                    // If enabled and it's a roof area, calculate azimuth now
                    if (checked && pvArea.type === 'roof-parallel' && pvArea.polygon) {
                        const azimuth = calculatePVAreaAzimuth(pvArea.polygon);
                        pvArea.azimuth = azimuth;
                        azimuthInput.value = azimuth;
                        // Update effective values
                        updateCrossTiltDirection(pvId);
                    }
                }
            }
        }
        
        // Set which field should be auto-calculated
        function setAutoCalculateField(pvId, field, checked) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (!pvArea || pvArea.type !== 'roof-parallel') return;
            
            if (checked) {
                // Uncheck other checkboxes
                ['tilt', 'heightTop', 'heightBottom'].forEach(f => {
                    if (f !== field) {
                        const checkbox = document.getElementById(`auto-calc-${f}-${pvId}`);
                        if (checkbox) checkbox.checked = false;
                    }
                });
                
                pvArea.autoCalculateField = field;
            } else {
                // If unchecking, clear auto-calculate field
                pvArea.autoCalculateField = null;
            }
            
            // Update input field states
            const tiltInput = document.getElementById(`tilt-${pvId}`);
            const heightTopInput = document.getElementById(`height-top-${pvId}`);
            const heightBottomInput = document.getElementById(`height-bottom-${pvId}`);
            
            if (tiltInput) tiltInput.disabled = (pvArea.autoCalculateField === 'tilt');
            if (heightTopInput) heightTopInput.disabled = (pvArea.autoCalculateField === 'heightTop');
            if (heightBottomInput) heightBottomInput.disabled = (pvArea.autoCalculateField === 'heightBottom');
            
            // Initialize default values if not set
            if (!pvArea.heightTop) pvArea.heightTop = 10; // Default 10m
            if (!pvArea.heightBottom) pvArea.heightBottom = 8; // Default 8m
            if (!pvArea.tilt) pvArea.tilt = 30; // Default 30°
            
            // Calculate the auto field if one is selected
            if (pvArea.autoCalculateField) {
                calculateAutoField(pvArea);
            }
            
            // Update UI to reflect changes
            updateUI();
        }
        
        // Calculate the auto-calculated field based on the other two
        function calculateAutoField(pvArea) {
            if (!pvArea.perpendicularDistance || pvArea.perpendicularDistance === 0) return;
            
            const distance = pvArea.perpendicularDistance;
            
            switch (pvArea.autoCalculateField) {
                case 'tilt':
                    // Calculate tilt from heights
                    if (pvArea.heightTop !== undefined && pvArea.heightBottom !== undefined) {
                        const heightDiff = pvArea.heightTop - pvArea.heightBottom;
                        const tiltRad = Math.atan(heightDiff / distance);
                        pvArea.tilt = Math.round(tiltRad * 180 / Math.PI * 10) / 10; // Round to 0.1°
                        pvArea.tilt = Math.max(0, Math.min(89, pvArea.tilt)); // Clamp to 0-89°
                    }
                    break;
                    
                case 'heightTop':
                    // Calculate top height from tilt and bottom height
                    if (pvArea.tilt !== undefined && pvArea.heightBottom !== undefined) {
                        const tiltRad = pvArea.tilt * Math.PI / 180;
                        const heightDiff = distance * Math.tan(tiltRad);
                        pvArea.heightTop = Math.round((pvArea.heightBottom + heightDiff) * 10) / 10; // Round to 0.1m
                    }
                    break;
                    
                case 'heightBottom':
                    // Calculate bottom height from tilt and top height
                    if (pvArea.tilt !== undefined && pvArea.heightTop !== undefined) {
                        const tiltRad = pvArea.tilt * Math.PI / 180;
                        const heightDiff = distance * Math.tan(tiltRad);
                        pvArea.heightBottom = Math.round((pvArea.heightTop - heightDiff) * 10) / 10; // Round to 0.1m
                    }
                    break;
            }
        }
        
        // Calculate azimuth for a PV area polygon
        function calculatePVAreaAzimuth(polygon) {
            const path = polygon.getPath();
            if (path.getLength() < 4) return 180; // Default
            
            // Get the first two points (P1-P2 edge)
            const p1 = path.getAt(0);
            const p2 = path.getAt(1);
            const p3 = path.getAt(2);
            
            // Use the same pixel-based calculation as in the rotation handler
            const projection = map.getProjection();
            const zoom = map.getZoom();
            const scale = Math.pow(2, zoom);
            
            // Convert to pixel coordinates
            const p1Pixel = projection.fromLatLngToPoint(p1);
            const p2Pixel = projection.fromLatLngToPoint(p2);
            const p3Pixel = projection.fromLatLngToPoint(p3);
            
            // Scale to current zoom
            p1Pixel.x *= scale; p1Pixel.y *= scale;
            p2Pixel.x *= scale; p2Pixel.y *= scale;
            p3Pixel.x *= scale; p3Pixel.y *= scale;
            
            // Calculate direction vector in pixel space
            const vPixel = {
                x: p2Pixel.x - p1Pixel.x,
                y: p2Pixel.y - p1Pixel.y
            };
            
            // Orthogonal in pixel space
            const orthoPixel = {
                x: -vPixel.y,
                y: vPixel.x
            };
            
            // Check direction
            const toP3Pixel = {
                x: p3Pixel.x - p1Pixel.x,
                y: p3Pixel.y - p1Pixel.y
            };
            
            const dotPixel = orthoPixel.x * toP3Pixel.x + orthoPixel.y * toP3Pixel.y;
            
            if (dotPixel < 0) {
                orthoPixel.x = -orthoPixel.x;
                orthoPixel.y = -orthoPixel.y;
            }
            
            // Normalize
            const lengthPixel = Math.sqrt(orthoPixel.x * orthoPixel.x + orthoPixel.y * orthoPixel.y);
            orthoPixel.x /= lengthPixel;
            orthoPixel.y /= lengthPixel;
            
            // Calculate end point for azimuth
            const centerPixel = {
                x: (p1Pixel.x + p2Pixel.x + p3Pixel.x) / 3,
                y: (p1Pixel.y + p2Pixel.y + p3Pixel.y) / 3
            };
            
            const endPixel = {
                x: centerPixel.x + orthoPixel.x * 100,
                y: centerPixel.y + orthoPixel.y * 100
            };
            
            // Convert back to geographic
            centerPixel.x /= scale; centerPixel.y /= scale;
            endPixel.x /= scale; endPixel.y /= scale;
            
            const centerPoint = projection.fromPointToLatLng(centerPixel);
            const endPoint = projection.fromPointToLatLng(endPixel);
            
            // Calculate azimuth
            const lat1 = centerPoint.lat() * Math.PI / 180;
            const lat2 = endPoint.lat() * Math.PI / 180;
            const dLon = (endPoint.lng() - centerPoint.lng()) * Math.PI / 180;
            
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            
            let azimuth = Math.atan2(y, x) * 180 / Math.PI;
            azimuth = ((azimuth + 360) % 360);
            azimuth = Math.round(azimuth * 10) / 10; // Round to 0.1°
            
            return azimuth;
        }
        
        // Calculate perpendicular distance between top and bottom edges
        function calculatePerpendicularDistance(polygon) {
            const path = polygon.getPath();
            if (path.getLength() !== 4) return null;
            
            // Get all four points
            const p1 = path.getAt(0);
            const p2 = path.getAt(1);
            const p3 = path.getAt(2);
            const p4 = path.getAt(3);
            
            // Get direction of top edge
            const topBearing = google.maps.geometry.spherical.computeHeading(p1, p2);
            
            // Find perpendicular direction
            const perpBearing = topBearing + 90;
            
            // Calculate perpendicular distance by projecting P3 onto the perpendicular direction from P1
            const directDist13 = google.maps.geometry.spherical.computeDistanceBetween(p1, p3);
            const bearing13 = google.maps.geometry.spherical.computeHeading(p1, p3);
            const angleDiff = Math.abs(bearing13 - perpBearing) * Math.PI / 180;
            const perpDistance = directDist13 * Math.cos(angleDiff);
            
            return Math.abs(perpDistance);
        }
        
        // Toggle auto-calculate reference height
        function toggleAutoCalculateReference(pvId, checked) {
            const pvArea = pvAreas.find(pv => pv.id === pvId);
            if (pvArea) {
                pvArea.autoCalculateReferenceHeight = checked;
                
                const referenceInput = document.getElementById(`reference-height-${pvId}`);
                if (referenceInput) {
                    referenceInput.disabled = checked;
                    
                    // If enabled, calculate reference height now
                    if (checked && pvArea.polygon) {
                        calculateReferenceHeight(pvArea);
                    }
                }
            }
        }
        
        // Calculate reference height using Google Elevation API
        async function calculateReferenceHeight(pvArea) {
            if (!pvArea.polygon) return;
            
            const path = pvArea.polygon.getPath();
            const locations = [];
            
            // Get all corner points
            for (let i = 0; i < path.getLength(); i++) {
                const point = path.getAt(i);
                locations.push({
                    lat: point.lat(),
                    lng: point.lng()
                });
            }
            
            // Create Elevation Service
            const elevator = new google.maps.ElevationService();
            
            try {
                const response = await elevator.getElevationForLocations({
                    locations: locations
                });
                
                if (response.results && response.results.length > 0) {
                    // Calculate average elevation
                    let totalElevation = 0;
                    response.results.forEach(result => {
                        totalElevation += result.elevation;
                    });
                    
                    const averageElevation = totalElevation / response.results.length;
                    pvArea.referenceHeight = Math.round(averageElevation * 10) / 10; // Round to 0.1m
                    
                    // Update UI
                    const referenceInput = document.getElementById(`reference-height-${pvArea.id}`);
                    if (referenceInput) {
                        referenceInput.value = pvArea.referenceHeight;
                    }
                    
                    // Recalculate heights if auto-calculate is enabled
                    if (pvArea.autoCalculateField) {
                        calculateAutoField(pvArea);
                    }
                    
                    updateUI();
                }
            } catch (error) {
                console.error('Error fetching elevation data:', error);
                showMessage('Fehler beim Abrufen der Höhendaten. Bitte manuell eingeben.', 'Fehler');
            }
        }
        
        // Module Type Manager functions
        function openModuleTypeManager() {
            const modal = document.getElementById('moduleTypeModal');
            const bootstrapModal = new bootstrap.Modal(modal);
            
            // Populate module types list
            updateModuleTypesList();
            
            bootstrapModal.show();
        }
        
        function updateModuleTypesList() {
            const listContainer = document.getElementById('moduleTypesList');
            
            listContainer.innerHTML = moduleTypes.map((module, index) => `
                <div class="card mb-3">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="flex-grow-1">
                                <h6 class="card-title mb-1">
                                    ${module.name}
                                    ${index < 2 ? '<span class="badge bg-secondary ms-2">Standard</span>' : ''}
                                </h6>
                                <p class="text-muted small mb-2">ID: ${module.id} | Bündelaufweitung: ${module.beamSpread}°</p>
                                <div class="mt-3">
                                    <small class="text-muted">Reflexionsprofil (cd/m² bei 100.000 lux):</small>
                                    <div class="table-responsive mt-1">
                                        <table class="table table-sm table-striped" style="font-size: 0.85rem;">
                                            <thead>
                                                <tr>
                                                    <th style="width: 50%;">Einfallswinkel</th>
                                                    <th style="width: 50%;">Reflexionsintensität</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${Object.entries(module.reflectionProfile).map(([angle, value]) => `
                                                    <tr>
                                                        <td>${angle}°</td>
                                                        <td>${Math.round(value).toLocaleString('de-DE')} cd/m²</td>
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                            ${index >= 2 ? `
                                <div class="ms-3">
                                    <button class="btn btn-sm btn-outline-primary me-1" onclick="editModuleType(${module.id})">
                                        <i class="bi bi-pencil"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger" onclick="deleteModuleType(${module.id})">
                                        <i class="bi bi-trash"></i>
                                    </button>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        function addNewModuleType() {
            // Reset form
            document.getElementById('moduleTypeForm').reset();
            document.getElementById('moduleTypeFormModalLabel').textContent = 'Neuer Modultyp';
            
            // Clear module ID (for new module)
            window.editingModuleId = null;
            
            // Hide the module types list modal first
            const listModal = bootstrap.Modal.getInstance(document.getElementById('moduleTypeModal'));
            if (listModal) {
                listModal.hide();
            }
            
            // Show form modal after a short delay to prevent stacking
            setTimeout(() => {
                const modal = new bootstrap.Modal(document.getElementById('moduleTypeFormModal'));
                modal.show();
            }, 300);
        }
        
        function saveModuleType() {
            const form = document.getElementById('moduleTypeForm');
            
            // Validate form
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }
            
            // Get form data
            const name = document.getElementById('moduleTypeName').value.trim();
            const beamSpread = parseFloat(document.getElementById('moduleTypeBeamSpread').value);
            
            // Check for duplicate names
            const duplicate = moduleTypes.find(m => 
                m.name === name && m.id !== window.editingModuleId
            );
            
            if (duplicate) {
                showMessage('Ein Modultyp mit diesem Namen existiert bereits.', 'Fehler');
                return;
            }
            
            // Get reflection profile
            const reflectionProfile = {};
            document.querySelectorAll('.reflection-input').forEach(input => {
                const angle = input.getAttribute('data-angle');
                reflectionProfile[angle] = parseFloat(input.value) || 0;
            });
            
            if (window.editingModuleId) {
                // Edit existing module
                const module = moduleTypes.find(m => m.id === window.editingModuleId);
                if (module) {
                    module.name = name;
                    module.beamSpread = beamSpread;
                    module.reflectionProfile = reflectionProfile;
                }
            } else {
                // Create new module
                const newId = Math.max(...moduleTypes.map(m => m.id)) + 1;
                moduleTypes.push({
                    id: newId,
                    name: name,
                    beamSpread: beamSpread,
                    reflectionProfile: reflectionProfile
                });
            }
            
            // Close form modal
            const formModal = bootstrap.Modal.getInstance(document.getElementById('moduleTypeFormModal'));
            if (formModal) {
                formModal.hide();
            }
            
            // Show the list modal again after a short delay
            setTimeout(() => {
                const listModal = new bootstrap.Modal(document.getElementById('moduleTypeModal'));
                listModal.show();
                updateModuleTypesList();
            }, 300);
            
            updateUI(); // Refresh PV areas to update dropdowns
        }
        
        function editModuleType(moduleId) {
            const module = moduleTypes.find(m => m.id === moduleId);
            if (!module) return;
            
            // Set form title
            document.getElementById('moduleTypeFormModalLabel').textContent = 'Modultyp bearbeiten';
            
            // Fill form with module data
            document.getElementById('moduleTypeName').value = module.name;
            document.getElementById('moduleTypeBeamSpread').value = module.beamSpread;
            
            // Fill reflection profile
            Object.entries(module.reflectionProfile).forEach(([angle, value]) => {
                const input = document.querySelector(`.reflection-input[data-angle="${angle}"]`);
                if (input) {
                    input.value = value;
                }
            });
            
            // Store module ID for saving
            window.editingModuleId = moduleId;
            
            // Hide the module types list modal first
            const listModal = bootstrap.Modal.getInstance(document.getElementById('moduleTypeModal'));
            if (listModal) {
                listModal.hide();
            }
            
            // Show form modal after a short delay
            setTimeout(() => {
                const modal = new bootstrap.Modal(document.getElementById('moduleTypeFormModal'));
                modal.show();
            }, 300);
        }
        
        function deleteModuleType(moduleId) {
            // Check if module type is in use
            const isInUse = pvAreas.some(pv => pv.moduleTypeId === moduleId);
            
            if (isInUse) {
                showMessage('Dieser Modultyp kann nicht gelöscht werden, da er bereits verwendet wird.', 'Fehler');
                return;
            }
            
            // Remove module type
            moduleTypes = moduleTypes.filter(m => m.id !== moduleId);
            updateModuleTypesList();
            updateUI(); // Refresh PV areas to update dropdowns
        }
        
        // Make initMap available globally
        window.initMap = initMap;
        
        // Also add to global scope as a backup
        if (typeof window.initMap !== 'function') {
            window.initMap = function() {
                console.log('Fallback initMap called');
                initMap();
            };
        }
        
        // Ensure corner heights panel is available after DOM loads
        window.addEventListener('load', function() {
            const panel = document.getElementById('cornerHeightsPanel');
            console.log('Window loaded - Corner heights panel exists:', !!panel);
            if (!panel) {
                console.error('Corner heights panel not found after window load!');
            }
        });
    </script>
    
    <!-- Google Maps API -->
    <script>
        // Ensure initMap is available before Google Maps tries to call it
        if (!window.initMap) {
            console.error('initMap not found, creating placeholder');
            window.initMap = function() {
                console.log('Placeholder initMap called, waiting for real function...');
                setTimeout(function() {
                    if (typeof initMap === 'function') {
                        initMap();
                    } else {
                        console.error('Real initMap function still not available');
                    }
                }, 100);
            };
        }
    </script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key={{ google_maps_api_key }}&libraries=drawing,places&callback=initMap"></script>
    
    <!-- PV Type Selection Modal -->
    <div class="modal fade" id="pvTypeModal" tabindex="-1" aria-labelledby="pvTypeModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="pvTypeModalLabel">PV-Anlagentyp auswählen</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="d-grid gap-2">
                        <button class="btn btn-outline-primary text-start p-3" onclick="selectPVType('roof-parallel')">
                            <i class="fas fa-home me-2"></i>
                            <strong>Dachanlage mit dachparallelen Modulen</strong>
                            <br>
                            <small class="text-muted">Module parallel zur Dachfläche montiert</small>
                        </button>
                        <button class="btn btn-outline-primary text-start p-3" onclick="selectPVType('roof-mounted')">
                            <i class="fas fa-solar-panel me-2"></i>
                            <strong>Dachanlage mit aufgeständerten Modulen</strong>
                            <br>
                            <small class="text-muted">Module mit Neigung auf Flachdach</small>
                        </button>
                        <button class="btn btn-outline-primary text-start p-3" onclick="selectPVType('facade')">
                            <i class="fas fa-building me-2"></i>
                            <strong>Fassadenanlage</strong>
                            <br>
                            <small class="text-muted">Module an der Gebäudefassade</small>
                        </button>
                        <button class="btn btn-outline-primary text-start p-3" onclick="selectPVType('ground')">
                            <i class="fas fa-seedling me-2"></i>
                            <strong>Freiflächenanlage</strong>
                            <br>
                            <small class="text-muted">Bodengebundene PV-Anlage</small>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Drawing Instructions Modal -->
    <div class="modal fade" id="drawingInstructionsModal" tabindex="-1" aria-labelledby="drawingInstructionsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="drawingInstructionsModalLabel">Zeichenanleitung</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="drawingInstructionsContent">
                    <!-- Content will be filled dynamically -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal" onclick="startDrawingAfterInstructions()">
                        <i class="fas fa-pencil-alt"></i> Zeichnen starten
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Bootstrap JavaScript Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Delete Confirmation Modal -->
    <div class="modal fade" id="deleteConfirmationModal" tabindex="-1" aria-labelledby="deleteConfirmationModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="deleteConfirmationModalLabel">PV-Fläche löschen</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="deleteConfirmationBody">
                    <!-- Content will be filled dynamically -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                    <button type="button" class="btn btn-danger" data-bs-dismiss="modal" onclick="confirmDeletePVArea()">
                        <i class="fas fa-trash"></i> Löschen
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- General Message Modal -->
    <div class="modal fade" id="messageModal" tabindex="-1" aria-labelledby="messageModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="messageModalLabel">Hinweis</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="messageModalBody">
                    <!-- Content will be filled dynamically -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Module Type Manager Modal -->
    <div class="modal fade" id="moduleTypeModal" tabindex="-1" aria-labelledby="moduleTypeModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-centered modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="moduleTypeModalLabel">Modultypen verwalten</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <button class="btn btn-sm btn-primary" onclick="addNewModuleType()">
                            <i class="bi bi-plus-circle"></i> Neuer Modultyp
                        </button>
                    </div>
                    <div id="moduleTypesList">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schließen</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Add/Edit Module Type Modal -->
    <div class="modal fade" id="moduleTypeFormModal" tabindex="-1" aria-labelledby="moduleTypeFormModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="moduleTypeFormModalLabel">Neuer Modultyp</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="moduleTypeForm">
                        <div class="mb-3">
                            <label for="moduleTypeName" class="form-label">Name</label>
                            <input type="text" class="form-control" id="moduleTypeName" required>
                        </div>
                        <div class="mb-3">
                            <label for="moduleTypeBeamSpread" class="form-label">
                                Bündelaufweitung (°)
                                <i class="bi bi-info-circle text-muted ms-1" 
                                   data-bs-toggle="tooltip" 
                                   data-bs-placement="top"
                                   title="Die Bündelaufweitung beschreibt die Streuung des reflektierten Lichts">
                                </i>
                            </label>
                            <input type="number" class="form-control" id="moduleTypeBeamSpread" 
                                   min="0" max="10" step="0.1" value="0.5" required>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">
                                Reflexionsprofil (cd/m² bei 100.000 lux)
                                <i class="bi bi-info-circle text-muted ms-1" 
                                   data-bs-toggle="tooltip" 
                                   data-bs-placement="top"
                                   title="Geben Sie die Reflexionsintensität für jeden Einfallswinkel an">
                                </i>
                            </label>
                            <div class="table-responsive">
                                <table class="table table-sm">
                                    <thead>
                                        <tr>
                                            <th>Einfallswinkel</th>
                                            <th>Reflexionsintensität</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>0°</td>
                                            <td><input type="number" class="form-control form-control-sm reflection-input" 
                                                       data-angle="0" min="0" required></td>
                                        </tr>
                                        <tr>
                                            <td>10°</td>
                                            <td><input type="number" class="form-control form-control-sm reflection-input" 
                                                       data-angle="10" min="0" required></td>
                                        </tr>
                                        <tr>
                                            <td>20°</td>
                                            <td><input type="number" class="form-control form-control-sm reflection-input" 
                                                       data-angle="20" min="0" required></td>
                                        </tr>
                                        <tr>
                                            <td>30°</td>
                                            <td><input type="number" class="form-control form-control-sm reflection-input" 
                                                       data-angle="30" min="0" required></td>
                                        </tr>
                                        <tr>
                                            <td>40°</td>
                                            <td><input type="number" class="form-control form-control-sm reflection-input" 
                                                       data-angle="40" min="0" required></td>
                                        </tr>
                                        <tr>
                                            <td>50°</td>
                                            <td><input type="number" class="form-control form-control-sm reflection-input" 
                                                       data-angle="50" min="0" required></td>
                                        </tr>
                                        <tr>
                                            <td>60°</td>
                                            <td><input type="number" class="form-control form-control-sm reflection-input" 
                                                       data-angle="60" min="0" required></td>
                                        </tr>
                                        <tr>
                                            <td>70°</td>
                                            <td><input type="number" class="form-control form-control-sm reflection-input" 
                                                       data-angle="70" min="0" required></td>
                                        </tr>
                                        <tr>
                                            <td>80°</td>
                                            <td><input type="number" class="form-control form-control-sm reflection-input" 
                                                       data-angle="80" min="0" required></td>
                                        </tr>
                                        <tr>
                                            <td>90°</td>
                                            <td><input type="number" class="form-control form-control-sm reflection-input" 
                                                       data-angle="90" min="0" required></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                    <button type="button" class="btn btn-primary" onclick="saveModuleType()">Speichern</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Corner Heights Side Panel -->
    <div id="cornerHeightsPanel" style="
        position: fixed;
        top: 60px;
        right: -600px;
        width: 600px;
        height: calc(100vh - 60px);
        background: white;
        box-shadow: -2px 0 10px rgba(0,0,0,0.1);
        z-index: 1100;
        transition: right 0.3s ease-in-out;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
    ">
        <div style="padding: 20px; border-bottom: 1px solid #dee2e6;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h5 style="margin: 0;">
                    <i class="fas fa-ruler-vertical"></i> Eckpunkt-Höhen und Koordinaten
                </h5>
                <button type="button" class="btn-close" onclick="closeCornerHeightsPanel()"></button>
            </div>
        </div>
        <div style="flex: 1; padding: 20px; overflow-y: auto;">
            <div id="cornerHeightsContent">
                <!-- Dynamically populated -->
            </div>
        </div>
        <div style="padding: 20px; border-top: 1px solid #dee2e6;">
            <div style="display: flex; gap: 10px;">
                <button type="button" class="btn btn-secondary flex-fill" onclick="closeCornerHeightsPanel()">Schließen</button>
                <button type="button" class="btn btn-primary flex-fill" onclick="saveCornerHeights()">Speichern</button>
            </div>
        </div>
    </div>
</body>
</html>